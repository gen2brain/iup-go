// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_Canvas_Brushes_H
#define WINRT_Microsoft_Graphics_Canvas_Brushes_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/Microsoft.Graphics.Canvas.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Numerics.2.h"
#include "winrt/impl/Windows.UI.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Brushes.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasBrush<D>::Opacity() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Opacity(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)this;
            check_hresult(_winrt_abi_type->get_Opacity(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasBrush<D>::Opacity(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Opacity(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)this;
            check_hresult(_winrt_abi_type->put_Opacity(value));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasBrush<D>::Transform() const
    {
        winrt::Windows::Foundation::Numerics::float3x2 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Transform(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)this;
            check_hresult(_winrt_abi_type->get_Transform(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasBrush<D>::Transform(winrt::Windows::Foundation::Numerics::float3x2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Transform(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)this;
            check_hresult(_winrt_abi_type->put_Transform(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasBrush<D>::Device() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Device(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>**)this;
            check_hresult(_winrt_abi_type->get_Device(&value));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::Image() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Image(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->get_Image(&value));
        }
        return winrt::Microsoft::Graphics::Canvas::ICanvasImage{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::Image(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Image(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->put_Image(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::ExtendX() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendX(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->get_ExtendX(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::ExtendX(winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ExtendX(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->put_ExtendX(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::ExtendY() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ExtendY(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->get_ExtendY(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::ExtendY(winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ExtendY(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->put_ExtendY(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::SourceRectangle() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceRectangle(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->get_SourceRectangle(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::SourceRectangle(winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SourceRectangle(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->put_SourceRectangle(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::Interpolation() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Interpolation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->get_Interpolation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrush<D>::Interpolation(winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Interpolation(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>**)this;
            check_hresult(_winrt_abi_type->put_Interpolation(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrushFactory<D>::Create(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) const
    {
        void* canvasImageBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&resourceCreator), &canvasImageBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&resourceCreator), &canvasImageBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasImageBrush{ canvasImageBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasImageBrushFactory<D>::CreateWithImage(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image) const
    {
        void* canvasImageBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithImage(*(void**)(&resourceCreator), *(void**)(&image), &canvasImageBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithImage(*(void**)(&resourceCreator), *(void**)(&image), &canvasImageBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasImageBrush{ canvasImageBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::StartPoint() const
    {
        winrt::Windows::Foundation::Numerics::float2 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StartPoint(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_StartPoint(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::StartPoint(winrt::Windows::Foundation::Numerics::float2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_StartPoint(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->put_StartPoint(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::EndPoint() const
    {
        winrt::Windows::Foundation::Numerics::float2 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EndPoint(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_EndPoint(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::EndPoint(winrt::Windows::Foundation::Numerics::float2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_EndPoint(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->put_EndPoint(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::Stops() const
    {
        uint32_t valueElements_impl_size{};
        struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Stops(&valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_Stops(&valueElements_impl_size, &valueElements));
        }
        return com_array<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::StopsHdr() const
    {
        uint32_t valueElements_impl_size{};
        struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StopsHdr(&valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_StopsHdr(&valueElements_impl_size, &valueElements));
        }
        return com_array<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::EdgeBehavior() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EdgeBehavior(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_EdgeBehavior(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::PreInterpolationSpace() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasColorSpace value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreInterpolationSpace(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_PreInterpolationSpace(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::PostInterpolationSpace() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasColorSpace value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PostInterpolationSpace(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_PostInterpolationSpace(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::BufferPrecision() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BufferPrecision(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_BufferPrecision(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrush<D>::AlphaMode() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AlphaMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_AlphaMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushFactory<D>::CreateSimple(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Color const& startColor, winrt::Windows::UI::Color const& endColor) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateSimple(*(void**)(&resourceCreator), impl::bind_in(startColor), impl::bind_in(endColor), &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateSimple(*(void**)(&resourceCreator), impl::bind_in(startColor), impl::bind_in(endColor), &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushFactory<D>::CreateWithStops(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithStops(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithStops(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushFactory<D>::CreateWithEdgeBehaviorAndAlphaMode(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithEdgeBehaviorAndAlphaMode(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithEdgeBehaviorAndAlphaMode(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushFactory<D>::CreateWithEdgeBehaviorAndInterpolationOptions(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& preInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& postInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithEdgeBehaviorAndInterpolationOptions(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), static_cast<int32_t>(preInterpolationSpace), static_cast<int32_t>(postInterpolationSpace), static_cast<int32_t>(bufferPrecision), &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithEdgeBehaviorAndInterpolationOptions(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), static_cast<int32_t>(preInterpolationSpace), static_cast<int32_t>(postInterpolationSpace), static_cast<int32_t>(bufferPrecision), &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float4 const& startColorHdr, winrt::Windows::Foundation::Numerics::float4 const& endColorHdr) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdrSimple(*(void**)(&resourceCreator), impl::bind_in(startColorHdr), impl::bind_in(endColorHdr), &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdrSimple(*(void**)(&resourceCreator), impl::bind_in(startColorHdr), impl::bind_in(endColorHdr), &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStopsHdr) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdrWithStops(*(void**)(&resourceCreator), gradientStopsHdr.size(), get_abi(gradientStopsHdr), &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdrWithStops(*(void**)(&resourceCreator), gradientStopsHdr.size(), get_abi(gradientStopsHdr), &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStopsHdr, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdrWithEdgeBehaviorAndAlphaMode(*(void**)(&resourceCreator), gradientStopsHdr.size(), get_abi(gradientStopsHdr), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdrWithEdgeBehaviorAndAlphaMode(*(void**)(&resourceCreator), gradientStopsHdr.size(), get_abi(gradientStopsHdr), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStopsHdr, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& preInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& postInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdrWithEdgeBehaviorAndInterpolationOptions(*(void**)(&resourceCreator), gradientStopsHdr.size(), get_abi(gradientStopsHdr), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), static_cast<int32_t>(preInterpolationSpace), static_cast<int32_t>(postInterpolationSpace), static_cast<int32_t>(bufferPrecision), &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdrWithEdgeBehaviorAndInterpolationOptions(*(void**)(&resourceCreator), gradientStopsHdr.size(), get_abi(gradientStopsHdr), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), static_cast<int32_t>(preInterpolationSpace), static_cast<int32_t>(postInterpolationSpace), static_cast<int32_t>(bufferPrecision), &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasLinearGradientBrushStatics<D>::CreateRainbow(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float eldritchness) const
    {
        void* canvasLinearGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateRainbow(*(void**)(&resourceCreator), eldritchness, &canvasLinearGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateRainbow(*(void**)(&resourceCreator), eldritchness, &canvasLinearGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush{ canvasLinearGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::Center() const
    {
        winrt::Windows::Foundation::Numerics::float2 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Center(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_Center(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::Center(winrt::Windows::Foundation::Numerics::float2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Center(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->put_Center(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::OriginOffset() const
    {
        winrt::Windows::Foundation::Numerics::float2 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_OriginOffset(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_OriginOffset(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::OriginOffset(winrt::Windows::Foundation::Numerics::float2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_OriginOffset(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->put_OriginOffset(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::RadiusX() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RadiusX(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_RadiusX(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::RadiusX(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_RadiusX(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->put_RadiusX(value));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::RadiusY() const
    {
        float value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_RadiusY(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_RadiusY(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::RadiusY(float value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_RadiusY(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->put_RadiusY(value));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::Stops() const
    {
        uint32_t valueElements_impl_size{};
        struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Stops(&valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_Stops(&valueElements_impl_size, &valueElements));
        }
        return com_array<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::StopsHdr() const
    {
        uint32_t valueElements_impl_size{};
        struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_StopsHdr(&valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_StopsHdr(&valueElements_impl_size, &valueElements));
        }
        return com_array<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::EdgeBehavior() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EdgeBehavior(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_EdgeBehavior(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::PreInterpolationSpace() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasColorSpace value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PreInterpolationSpace(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_PreInterpolationSpace(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::PostInterpolationSpace() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasColorSpace value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_PostInterpolationSpace(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_PostInterpolationSpace(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::BufferPrecision() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BufferPrecision(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_BufferPrecision(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrush<D>::AlphaMode() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AlphaMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>**)this;
            check_hresult(_winrt_abi_type->get_AlphaMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushFactory<D>::CreateSimple(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Color const& startColor, winrt::Windows::UI::Color const& endColor) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateSimple(*(void**)(&resourceCreator), impl::bind_in(startColor), impl::bind_in(endColor), &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateSimple(*(void**)(&resourceCreator), impl::bind_in(startColor), impl::bind_in(endColor), &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushFactory<D>::CreateWithStops(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithStops(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithStops(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushFactory<D>::CreateWithEdgeBehaviorAndAlphaMode(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithEdgeBehaviorAndAlphaMode(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithEdgeBehaviorAndAlphaMode(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushFactory<D>::CreateWithEdgeBehaviorAndInterpolationOptions(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& preInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& postInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithEdgeBehaviorAndInterpolationOptions(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), static_cast<int32_t>(preInterpolationSpace), static_cast<int32_t>(postInterpolationSpace), static_cast<int32_t>(bufferPrecision), &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithEdgeBehaviorAndInterpolationOptions(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), static_cast<int32_t>(preInterpolationSpace), static_cast<int32_t>(postInterpolationSpace), static_cast<int32_t>(bufferPrecision), &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float4 const& startColorHdr, winrt::Windows::Foundation::Numerics::float4 const& endColorHdr) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdrSimple(*(void**)(&resourceCreator), impl::bind_in(startColorHdr), impl::bind_in(endColorHdr), &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdrSimple(*(void**)(&resourceCreator), impl::bind_in(startColorHdr), impl::bind_in(endColorHdr), &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStops) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdrWithStops(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdrWithStops(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdrWithEdgeBehaviorAndAlphaMode(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdrWithEdgeBehaviorAndAlphaMode(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& preInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& postInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdrWithEdgeBehaviorAndInterpolationOptions(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), static_cast<int32_t>(preInterpolationSpace), static_cast<int32_t>(postInterpolationSpace), static_cast<int32_t>(bufferPrecision), &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdrWithEdgeBehaviorAndInterpolationOptions(*(void**)(&resourceCreator), gradientStops.size(), get_abi(gradientStops), static_cast<int32_t>(edgeBehavior), static_cast<int32_t>(alphaMode), static_cast<int32_t>(preInterpolationSpace), static_cast<int32_t>(postInterpolationSpace), static_cast<int32_t>(bufferPrecision), &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasRadialGradientBrushStatics<D>::CreateRainbow(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float eldritchness) const
    {
        void* canvasRadialGradientBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateRainbow(*(void**)(&resourceCreator), eldritchness, &canvasRadialGradientBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateRainbow(*(void**)(&resourceCreator), eldritchness, &canvasRadialGradientBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush{ canvasRadialGradientBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasSolidColorBrush<D>::Color() const
    {
        winrt::Windows::UI::Color value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Color(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>**)this;
            check_hresult(_winrt_abi_type->get_Color(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasSolidColorBrush<D>::Color(winrt::Windows::UI::Color const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Color(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>**)this;
            check_hresult(_winrt_abi_type->put_Color(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasSolidColorBrush<D>::ColorHdr() const
    {
        winrt::Windows::Foundation::Numerics::float4 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ColorHdr(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>**)this;
            check_hresult(_winrt_abi_type->get_ColorHdr(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasSolidColorBrush<D>::ColorHdr(winrt::Windows::Foundation::Numerics::float4 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_ColorHdr(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>**)this;
            check_hresult(_winrt_abi_type->put_ColorHdr(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasSolidColorBrushFactory<D>::Create(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Color const& color) const
    {
        void* canvasSolidColorBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&resourceCreator), impl::bind_in(color), &canvasSolidColorBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushFactory>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&resourceCreator), impl::bind_in(color), &canvasSolidColorBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasSolidColorBrush{ canvasSolidColorBrush, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_Brushes_ICanvasSolidColorBrushStatics<D>::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float4 const& colorHdr) const
    {
        void* canvasSolidColorBrush{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateHdr(*(void**)(&resourceCreator), impl::bind_in(colorHdr), &canvasSolidColorBrush));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushStatics>**)this;
            check_hresult(_winrt_abi_type->CreateHdr(*(void**)(&resourceCreator), impl::bind_in(colorHdr), &canvasSolidColorBrush));
        }
        return winrt::Microsoft::Graphics::Canvas::Brushes::CanvasSolidColorBrush{ canvasSolidColorBrush, take_ownership_from_abi };
    }
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush>
    {
        int32_t __stdcall get_Opacity(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Opacity());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Opacity(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Opacity(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Transform(winrt::Windows::Foundation::Numerics::float3x2* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float3x2>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float3x2>(this->shim().Transform());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Transform(winrt::Windows::Foundation::Numerics::float3x2 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Transform(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Device(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush>
    {
        int32_t __stdcall get_Image(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::ICanvasImage>(this->shim().Image());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Image(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Image(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendX(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior>(this->shim().ExtendX());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExtendX(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExtendX(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ExtendY(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior>(this->shim().ExtendY());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ExtendY(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ExtendY(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SourceRectangle(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(this->shim().SourceRectangle());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SourceRectangle(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SourceRectangle(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Interpolation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation>(this->shim().Interpolation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Interpolation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Interpolation(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory>
    {
        int32_t __stdcall Create(void* resourceCreator, void** canvasImageBrush) noexcept final try
        {
            clear_abi(canvasImageBrush);
            typename D::abi_guard guard(this->shim());
            *canvasImageBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasImageBrush>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithImage(void* resourceCreator, void* image, void** canvasImageBrush) noexcept final try
        {
            clear_abi(canvasImageBrush);
            typename D::abi_guard guard(this->shim());
            *canvasImageBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasImageBrush>(this->shim().CreateWithImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush>
    {
        int32_t __stdcall get_StartPoint(winrt::Windows::Foundation::Numerics::float2* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float2>(this->shim().StartPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_StartPoint(winrt::Windows::Foundation::Numerics::float2 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StartPoint(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EndPoint(winrt::Windows::Foundation::Numerics::float2* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float2>(this->shim().EndPoint());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_EndPoint(winrt::Windows::Foundation::Numerics::float2 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EndPoint(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Stops(uint32_t* __valueElementsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().Stops());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StopsHdr(uint32_t* __valueElementsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().StopsHdr());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EdgeBehavior(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior>(this->shim().EdgeBehavior());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreInterpolationSpace(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace>(this->shim().PreInterpolationSpace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PostInterpolationSpace(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace>(this->shim().PostInterpolationSpace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BufferPrecision(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision>(this->shim().BufferPrecision());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AlphaMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode>(this->shim().AlphaMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory>
    {
        int32_t __stdcall CreateSimple(void* resourceCreator, struct struct_Windows_UI_Color startColor, struct struct_Windows_UI_Color endColor, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateSimple(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::UI::Color const*>(&startColor), *reinterpret_cast<winrt::Windows::UI::Color const*>(&endColor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithStops(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop* gradientStops, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateWithStops(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops) + __gradientStopsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithEdgeBehaviorAndAlphaMode(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop* gradientStops, int32_t edgeBehavior, int32_t alphaMode, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateWithEdgeBehaviorAndAlphaMode(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops) + __gradientStopsSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&edgeBehavior), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithEdgeBehaviorAndInterpolationOptions(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop* gradientStops, int32_t edgeBehavior, int32_t alphaMode, int32_t preInterpolationSpace, int32_t postInterpolationSpace, int32_t bufferPrecision, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateWithEdgeBehaviorAndInterpolationOptions(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops) + __gradientStopsSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&edgeBehavior), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const*>(&preInterpolationSpace), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const*>(&postInterpolationSpace), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const*>(&bufferPrecision)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics>
    {
        int32_t __stdcall CreateHdrSimple(void* resourceCreator, winrt::Windows::Foundation::Numerics::float4 startColorHdr, winrt::Windows::Foundation::Numerics::float4 endColorHdr, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&startColorHdr), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&endColorHdr)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateHdrWithStops(void* resourceCreator, uint32_t __gradientStopsHdrSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr* gradientStopsHdr, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStopsHdr), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStopsHdr) + __gradientStopsHdrSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateHdrWithEdgeBehaviorAndAlphaMode(void* resourceCreator, uint32_t __gradientStopsHdrSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr* gradientStopsHdr, int32_t edgeBehavior, int32_t alphaMode, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStopsHdr), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStopsHdr) + __gradientStopsHdrSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&edgeBehavior), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateHdrWithEdgeBehaviorAndInterpolationOptions(void* resourceCreator, uint32_t __gradientStopsHdrSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr* gradientStopsHdr, int32_t edgeBehavior, int32_t alphaMode, int32_t preInterpolationSpace, int32_t postInterpolationSpace, int32_t bufferPrecision, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStopsHdr), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStopsHdr) + __gradientStopsHdrSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&edgeBehavior), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const*>(&preInterpolationSpace), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const*>(&postInterpolationSpace), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const*>(&bufferPrecision)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateRainbow(void* resourceCreator, float eldritchness, void** canvasLinearGradientBrush) noexcept final try
        {
            clear_abi(canvasLinearGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasLinearGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush>(this->shim().CreateRainbow(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), eldritchness));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush>
    {
        int32_t __stdcall get_Center(winrt::Windows::Foundation::Numerics::float2* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float2>(this->shim().Center());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Center(winrt::Windows::Foundation::Numerics::float2 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Center(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OriginOffset(winrt::Windows::Foundation::Numerics::float2* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float2>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float2>(this->shim().OriginOffset());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_OriginOffset(winrt::Windows::Foundation::Numerics::float2 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OriginOffset(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RadiusX(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().RadiusX());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RadiusX(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RadiusX(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RadiusY(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().RadiusY());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RadiusY(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RadiusY(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Stops(uint32_t* __valueElementsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().Stops());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_StopsHdr(uint32_t* __valueElementsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().StopsHdr());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EdgeBehavior(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior>(this->shim().EdgeBehavior());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PreInterpolationSpace(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace>(this->shim().PreInterpolationSpace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_PostInterpolationSpace(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace>(this->shim().PostInterpolationSpace());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BufferPrecision(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision>(this->shim().BufferPrecision());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AlphaMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode>(this->shim().AlphaMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory>
    {
        int32_t __stdcall CreateSimple(void* resourceCreator, struct struct_Windows_UI_Color startColor, struct struct_Windows_UI_Color endColor, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateSimple(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::UI::Color const*>(&startColor), *reinterpret_cast<winrt::Windows::UI::Color const*>(&endColor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithStops(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop* gradientStops, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateWithStops(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops) + __gradientStopsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithEdgeBehaviorAndAlphaMode(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop* gradientStops, int32_t edgeBehavior, int32_t alphaMode, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateWithEdgeBehaviorAndAlphaMode(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops) + __gradientStopsSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&edgeBehavior), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithEdgeBehaviorAndInterpolationOptions(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStop* gradientStops, int32_t edgeBehavior, int32_t alphaMode, int32_t preInterpolationSpace, int32_t postInterpolationSpace, int32_t bufferPrecision, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateWithEdgeBehaviorAndInterpolationOptions(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const *>(gradientStops) + __gradientStopsSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&edgeBehavior), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const*>(&preInterpolationSpace), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const*>(&postInterpolationSpace), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const*>(&bufferPrecision)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics>
    {
        int32_t __stdcall CreateHdrSimple(void* resourceCreator, winrt::Windows::Foundation::Numerics::float4 startColorHdr, winrt::Windows::Foundation::Numerics::float4 endColorHdr, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&startColorHdr), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&endColorHdr)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateHdrWithStops(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr* gradientStops, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStops) + __gradientStopsSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateHdrWithEdgeBehaviorAndAlphaMode(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr* gradientStops, int32_t edgeBehavior, int32_t alphaMode, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStops) + __gradientStopsSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&edgeBehavior), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateHdrWithEdgeBehaviorAndInterpolationOptions(void* resourceCreator, uint32_t __gradientStopsSize, struct struct_Microsoft_Graphics_Canvas_Brushes_CanvasGradientStopHdr* gradientStops, int32_t edgeBehavior, int32_t alphaMode, int32_t preInterpolationSpace, int32_t postInterpolationSpace, int32_t bufferPrecision, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStops), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const *>(gradientStops) + __gradientStopsSize), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const*>(&edgeBehavior), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const*>(&preInterpolationSpace), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const*>(&postInterpolationSpace), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const*>(&bufferPrecision)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateRainbow(void* resourceCreator, float eldritchness, void** canvasRadialGradientBrush) noexcept final try
        {
            clear_abi(canvasRadialGradientBrush);
            typename D::abi_guard guard(this->shim());
            *canvasRadialGradientBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush>(this->shim().CreateRainbow(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), eldritchness));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush>
    {
        int32_t __stdcall get_Color(struct struct_Windows_UI_Color* value) noexcept final try
        {
            zero_abi<winrt::Windows::UI::Color>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::UI::Color>(this->shim().Color());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Color(struct struct_Windows_UI_Color value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Color(*reinterpret_cast<winrt::Windows::UI::Color const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ColorHdr(winrt::Windows::Foundation::Numerics::float4* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float4>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float4>(this->shim().ColorHdr());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ColorHdr(winrt::Windows::Foundation::Numerics::float4 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ColorHdr(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushFactory>
    {
        int32_t __stdcall Create(void* resourceCreator, struct struct_Windows_UI_Color color, void** canvasSolidColorBrush) noexcept final try
        {
            clear_abi(canvasSolidColorBrush);
            typename D::abi_guard guard(this->shim());
            *canvasSolidColorBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasSolidColorBrush>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushStatics>
    {
        int32_t __stdcall CreateHdr(void* resourceCreator, winrt::Windows::Foundation::Numerics::float4 colorHdr, void** canvasSolidColorBrush) noexcept final try
        {
            clear_abi(canvasSolidColorBrush);
            typename D::abi_guard guard(this->shim());
            *canvasSolidColorBrush = detach_from<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasSolidColorBrush>(this->shim().CreateHdr(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&colorHdr)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Graphics::Canvas::Brushes
{
    inline CanvasImageBrush::CanvasImageBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) :
        CanvasImageBrush(impl::call_factory<CanvasImageBrush, ICanvasImageBrushFactory>([&](ICanvasImageBrushFactory const& f) { return f.Create(resourceCreator); }))
    {
    }
    inline CanvasImageBrush::CanvasImageBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image) :
        CanvasImageBrush(impl::call_factory<CanvasImageBrush, ICanvasImageBrushFactory>([&](ICanvasImageBrushFactory const& f) { return f.CreateWithImage(resourceCreator, image); }))
    {
    }
    inline CanvasLinearGradientBrush::CanvasLinearGradientBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Color const& startColor, winrt::Windows::UI::Color const& endColor) :
        CanvasLinearGradientBrush(impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushFactory>([&](ICanvasLinearGradientBrushFactory const& f) { return f.CreateSimple(resourceCreator, startColor, endColor); }))
    {
    }
    inline CanvasLinearGradientBrush::CanvasLinearGradientBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops) :
        CanvasLinearGradientBrush(impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushFactory>([&](ICanvasLinearGradientBrushFactory const& f) { return f.CreateWithStops(resourceCreator, gradientStops); }))
    {
    }
    inline CanvasLinearGradientBrush::CanvasLinearGradientBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode) :
        CanvasLinearGradientBrush(impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushFactory>([&](ICanvasLinearGradientBrushFactory const& f) { return f.CreateWithEdgeBehaviorAndAlphaMode(resourceCreator, gradientStops, edgeBehavior, alphaMode); }))
    {
    }
    inline CanvasLinearGradientBrush::CanvasLinearGradientBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& preInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& postInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision) :
        CanvasLinearGradientBrush(impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushFactory>([&](ICanvasLinearGradientBrushFactory const& f) { return f.CreateWithEdgeBehaviorAndInterpolationOptions(resourceCreator, gradientStops, edgeBehavior, alphaMode, preInterpolationSpace, postInterpolationSpace, bufferPrecision); }))
    {
    }
    inline auto CanvasLinearGradientBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float4 const& startColorHdr, winrt::Windows::Foundation::Numerics::float4 const& endColorHdr)
    {
        return impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushStatics>([&](ICanvasLinearGradientBrushStatics const& f) { return f.CreateHdr(resourceCreator, startColorHdr, endColorHdr); });
    }
    inline auto CanvasLinearGradientBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStopsHdr)
    {
        return impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushStatics>([&](ICanvasLinearGradientBrushStatics const& f) { return f.CreateHdr(resourceCreator, gradientStopsHdr); });
    }
    inline auto CanvasLinearGradientBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStopsHdr, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode)
    {
        return impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushStatics>([&](ICanvasLinearGradientBrushStatics const& f) { return f.CreateHdr(resourceCreator, gradientStopsHdr, edgeBehavior, alphaMode); });
    }
    inline auto CanvasLinearGradientBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStopsHdr, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& preInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& postInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision)
    {
        return impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushStatics>([&](ICanvasLinearGradientBrushStatics const& f) { return f.CreateHdr(resourceCreator, gradientStopsHdr, edgeBehavior, alphaMode, preInterpolationSpace, postInterpolationSpace, bufferPrecision); });
    }
    inline auto CanvasLinearGradientBrush::CreateRainbow(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float eldritchness)
    {
        return impl::call_factory<CanvasLinearGradientBrush, ICanvasLinearGradientBrushStatics>([&](ICanvasLinearGradientBrushStatics const& f) { return f.CreateRainbow(resourceCreator, eldritchness); });
    }
    inline CanvasRadialGradientBrush::CanvasRadialGradientBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Color const& startColor, winrt::Windows::UI::Color const& endColor) :
        CanvasRadialGradientBrush(impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushFactory>([&](ICanvasRadialGradientBrushFactory const& f) { return f.CreateSimple(resourceCreator, startColor, endColor); }))
    {
    }
    inline CanvasRadialGradientBrush::CanvasRadialGradientBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops) :
        CanvasRadialGradientBrush(impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushFactory>([&](ICanvasRadialGradientBrushFactory const& f) { return f.CreateWithStops(resourceCreator, gradientStops); }))
    {
    }
    inline CanvasRadialGradientBrush::CanvasRadialGradientBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode) :
        CanvasRadialGradientBrush(impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushFactory>([&](ICanvasRadialGradientBrushFactory const& f) { return f.CreateWithEdgeBehaviorAndAlphaMode(resourceCreator, gradientStops, edgeBehavior, alphaMode); }))
    {
    }
    inline CanvasRadialGradientBrush::CanvasRadialGradientBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStop const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& preInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& postInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision) :
        CanvasRadialGradientBrush(impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushFactory>([&](ICanvasRadialGradientBrushFactory const& f) { return f.CreateWithEdgeBehaviorAndInterpolationOptions(resourceCreator, gradientStops, edgeBehavior, alphaMode, preInterpolationSpace, postInterpolationSpace, bufferPrecision); }))
    {
    }
    inline auto CanvasRadialGradientBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float4 const& startColorHdr, winrt::Windows::Foundation::Numerics::float4 const& endColorHdr)
    {
        return impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushStatics>([&](ICanvasRadialGradientBrushStatics const& f) { return f.CreateHdr(resourceCreator, startColorHdr, endColorHdr); });
    }
    inline auto CanvasRadialGradientBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStops)
    {
        return impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushStatics>([&](ICanvasRadialGradientBrushStatics const& f) { return f.CreateHdr(resourceCreator, gradientStops); });
    }
    inline auto CanvasRadialGradientBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode)
    {
        return impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushStatics>([&](ICanvasRadialGradientBrushStatics const& f) { return f.CreateHdr(resourceCreator, gradientStops, edgeBehavior, alphaMode); });
    }
    inline auto CanvasRadialGradientBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasGradientStopHdr const> gradientStops, winrt::Microsoft::Graphics::Canvas::CanvasEdgeBehavior const& edgeBehavior, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& preInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasColorSpace const& postInterpolationSpace, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision)
    {
        return impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushStatics>([&](ICanvasRadialGradientBrushStatics const& f) { return f.CreateHdr(resourceCreator, gradientStops, edgeBehavior, alphaMode, preInterpolationSpace, postInterpolationSpace, bufferPrecision); });
    }
    inline auto CanvasRadialGradientBrush::CreateRainbow(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float eldritchness)
    {
        return impl::call_factory<CanvasRadialGradientBrush, ICanvasRadialGradientBrushStatics>([&](ICanvasRadialGradientBrushStatics const& f) { return f.CreateRainbow(resourceCreator, eldritchness); });
    }
    inline CanvasSolidColorBrush::CanvasSolidColorBrush(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Color const& color) :
        CanvasSolidColorBrush(impl::call_factory<CanvasSolidColorBrush, ICanvasSolidColorBrushFactory>([&](ICanvasSolidColorBrushFactory const& f) { return f.Create(resourceCreator, color); }))
    {
    }
    inline auto CanvasSolidColorBrush::CreateHdr(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float4 const& colorHdr)
    {
        return impl::call_factory<CanvasSolidColorBrush, ICanvasSolidColorBrushStatics>([&](ICanvasSolidColorBrushStatics const& f) { return f.CreateHdr(resourceCreator, colorHdr); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrush> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasImageBrushFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrush> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasLinearGradientBrushStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrush> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasRadialGradientBrushStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrush> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasSolidColorBrushStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasImageBrush> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasLinearGradientBrush> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasRadialGradientBrush> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::Brushes::CanvasSolidColorBrush> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
