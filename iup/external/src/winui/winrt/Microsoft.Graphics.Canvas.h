// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.250303.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_Canvas_H
#define WINRT_Microsoft_Graphics_Canvas_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.250303.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.250303.1"
#include "winrt/impl/Microsoft.Graphics.Canvas.Brushes.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Effects.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Geometry.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Svg.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.Text.2.h"
#include "winrt/impl/Microsoft.UI.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Numerics.2.h"
#include "winrt/impl/Windows.Graphics.DirectX.2.h"
#include "winrt/impl/Windows.Graphics.DirectX.Direct3D11.2.h"
#include "winrt/impl/Windows.Graphics.Effects.2.h"
#include "winrt/impl/Windows.Graphics.Imaging.2.h"
#include "winrt/impl/Windows.Storage.Streams.2.h"
#include "winrt/impl/Windows.UI.2.h"
#include "winrt/impl/Windows.UI.Core.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SizeInPixels() const
    {
        winrt::Windows::Graphics::Imaging::BitmapSize size{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SizeInPixels(put_abi(size)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->get_SizeInPixels(put_abi(size)));
        }
        return size;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::Size() const
    {
        winrt::Windows::Foundation::Size size{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Size(put_abi(size)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->get_Size(put_abi(size)));
        }
        return size;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::Bounds() const
    {
        winrt::Windows::Foundation::Rect bounds{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Bounds(put_abi(bounds)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->get_Bounds(put_abi(bounds)));
        }
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::Format() const
    {
        winrt::Windows::Graphics::DirectX::DirectXPixelFormat value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Format(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->get_Format(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::AlphaMode() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AlphaMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->get_AlphaMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SaveAsync(param::hstring const& fileName) const
    {
        void* asyncAction{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveToFileAsync(*(void**)(&fileName), &asyncAction));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SaveToFileAsync(*(void**)(&fileName), &asyncAction));
        }
        return winrt::Windows::Foundation::IAsyncAction{ asyncAction, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SaveAsync(param::hstring const& fileName, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat) const
    {
        void* asyncAction{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveToFileWithBitmapFileFormatAsync(*(void**)(&fileName), static_cast<int32_t>(fileFormat), &asyncAction));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SaveToFileWithBitmapFileFormatAsync(*(void**)(&fileName), static_cast<int32_t>(fileFormat), &asyncAction));
        }
        return winrt::Windows::Foundation::IAsyncAction{ asyncAction, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SaveAsync(param::hstring const& fileName, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat, float quality) const
    {
        void* asyncAction{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveToFileWithBitmapFileFormatAndQualityAsync(*(void**)(&fileName), static_cast<int32_t>(fileFormat), quality, &asyncAction));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SaveToFileWithBitmapFileFormatAndQualityAsync(*(void**)(&fileName), static_cast<int32_t>(fileFormat), quality, &asyncAction));
        }
        return winrt::Windows::Foundation::IAsyncAction{ asyncAction, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SaveAsync(winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat) const
    {
        void* asyncAction{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveToStreamAsync(*(void**)(&stream), static_cast<int32_t>(fileFormat), &asyncAction));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SaveToStreamAsync(*(void**)(&stream), static_cast<int32_t>(fileFormat), &asyncAction));
        }
        return winrt::Windows::Foundation::IAsyncAction{ asyncAction, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SaveAsync(winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat, float quality) const
    {
        void* asyncAction{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveToStreamWithQualityAsync(*(void**)(&stream), static_cast<int32_t>(fileFormat), quality, &asyncAction));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SaveToStreamWithQualityAsync(*(void**)(&stream), static_cast<int32_t>(fileFormat), quality, &asyncAction));
        }
        return winrt::Windows::Foundation::IAsyncAction{ asyncAction, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::GetPixelBytes() const
    {
        uint32_t valueElements_impl_size{};
        uint8_t* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPixelBytes(&valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->GetPixelBytes(&valueElements_impl_size, &valueElements));
        }
        return com_array<uint8_t>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::GetPixelBytes(int32_t left, int32_t top, int32_t width, int32_t height) const
    {
        uint32_t valueElements_impl_size{};
        uint8_t* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPixelBytesWithSubrectangle(left, top, width, height, &valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->GetPixelBytesWithSubrectangle(left, top, width, height, &valueElements_impl_size, &valueElements));
        }
        return com_array<uint8_t>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::GetPixelBytes(winrt::Windows::Storage::Streams::IBuffer const& buffer) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPixelBytesWithBuffer(*(void**)(&buffer)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->GetPixelBytesWithBuffer(*(void**)(&buffer)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::GetPixelBytes(winrt::Windows::Storage::Streams::IBuffer const& buffer, int32_t left, int32_t top, int32_t width, int32_t height) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPixelBytesWithBufferAndSubrectangle(*(void**)(&buffer), left, top, width, height));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->GetPixelBytesWithBufferAndSubrectangle(*(void**)(&buffer), left, top, width, height));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::GetPixelColors() const
    {
        uint32_t valueElements_impl_size{};
        struct struct_Windows_UI_Color* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPixelColors(&valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->GetPixelColors(&valueElements_impl_size, &valueElements));
        }
        return com_array<winrt::Windows::UI::Color>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::GetPixelColors(int32_t left, int32_t top, int32_t width, int32_t height) const
    {
        uint32_t valueElements_impl_size{};
        struct struct_Windows_UI_Color* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetPixelColorsWithSubrectangle(left, top, width, height, &valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->GetPixelColorsWithSubrectangle(left, top, width, height, &valueElements_impl_size, &valueElements));
        }
        return com_array<winrt::Windows::UI::Color>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SetPixelBytes(array_view<uint8_t const> valueElements) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPixelBytes(valueElements.size(), get_abi(valueElements)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SetPixelBytes(valueElements.size(), get_abi(valueElements)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SetPixelBytes(array_view<uint8_t const> valueElements, int32_t left, int32_t top, int32_t width, int32_t height) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPixelBytesWithSubrectangle(valueElements.size(), get_abi(valueElements), left, top, width, height));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SetPixelBytesWithSubrectangle(valueElements.size(), get_abi(valueElements), left, top, width, height));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SetPixelBytes(winrt::Windows::Storage::Streams::IBuffer const& buffer) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPixelBytesWithBuffer(*(void**)(&buffer)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SetPixelBytesWithBuffer(*(void**)(&buffer)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SetPixelBytes(winrt::Windows::Storage::Streams::IBuffer const& buffer, int32_t left, int32_t top, int32_t width, int32_t height) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPixelBytesWithBufferAndSubrectangle(*(void**)(&buffer), left, top, width, height));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SetPixelBytesWithBufferAndSubrectangle(*(void**)(&buffer), left, top, width, height));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SetPixelColors(array_view<winrt::Windows::UI::Color const> valueElements) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPixelColors(valueElements.size(), get_abi(valueElements)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SetPixelColors(valueElements.size(), get_abi(valueElements)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::SetPixelColors(array_view<winrt::Windows::UI::Color const> valueElements, int32_t left, int32_t top, int32_t width, int32_t height) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SetPixelColorsWithSubrectangle(valueElements.size(), get_abi(valueElements), left, top, width, height));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->SetPixelColorsWithSubrectangle(valueElements.size(), get_abi(valueElements), left, top, width, height));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::CopyPixelsFromBitmap(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& otherBitmap) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CopyPixelsFromBitmap(*(void**)(&otherBitmap)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->CopyPixelsFromBitmap(*(void**)(&otherBitmap)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::CopyPixelsFromBitmap(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& otherBitmap, int32_t destX, int32_t destY) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CopyPixelsFromBitmapWithDestPoint(*(void**)(&otherBitmap), destX, destY));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->CopyPixelsFromBitmapWithDestPoint(*(void**)(&otherBitmap), destX, destY));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmap<D>::CopyPixelsFromBitmap(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& otherBitmap, int32_t destX, int32_t destY, int32_t sourceRectLeft, int32_t sourceRectTop, int32_t sourceRectWidth, int32_t sourceRectHeight) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CopyPixelsFromBitmapWithDestPointAndSourceRect(*(void**)(&otherBitmap), destX, destY, sourceRectLeft, sourceRectTop, sourceRectWidth, sourceRectHeight));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>**)this;
            check_hresult(_winrt_abi_type->CopyPixelsFromBitmapWithDestPointAndSourceRect(*(void**)(&otherBitmap), destX, destY, sourceRectLeft, sourceRectTop, sourceRectWidth, sourceRectHeight));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11Surface(*(void**)(&resourceCreator), *(void**)(&surface), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11Surface(*(void**)(&resourceCreator), *(void**)(&surface), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface, float dpi) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11SurfaceWithDpi(*(void**)(&resourceCreator), *(void**)(&surface), dpi, &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11SurfaceWithDpi(*(void**)(&resourceCreator), *(void**)(&surface), dpi, &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11SurfaceWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&surface), dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11SurfaceWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&surface), dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<uint8_t const> bytes, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromBytes(*(void**)(&resourceCreator), bytes.size(), get_abi(bytes), widthInPixels, heightInPixels, static_cast<int32_t>(format), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromBytes(*(void**)(&resourceCreator), bytes.size(), get_abi(bytes), widthInPixels, heightInPixels, static_cast<int32_t>(format), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<uint8_t const> bytes, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, float dpi) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromBytesWithDpi(*(void**)(&resourceCreator), bytes.size(), get_abi(bytes), widthInPixels, heightInPixels, static_cast<int32_t>(format), dpi, &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromBytesWithDpi(*(void**)(&resourceCreator), bytes.size(), get_abi(bytes), widthInPixels, heightInPixels, static_cast<int32_t>(format), dpi, &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<uint8_t const> bytes, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromBytesWithDpiAndAlpha(*(void**)(&resourceCreator), bytes.size(), get_abi(bytes), widthInPixels, heightInPixels, static_cast<int32_t>(format), dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromBytesWithDpiAndAlpha(*(void**)(&resourceCreator), bytes.size(), get_abi(bytes), widthInPixels, heightInPixels, static_cast<int32_t>(format), dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IBuffer const& buffer, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromBytesWithBuffer(*(void**)(&resourceCreator), *(void**)(&buffer), widthInPixels, heightInPixels, static_cast<int32_t>(format), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromBytesWithBuffer(*(void**)(&resourceCreator), *(void**)(&buffer), widthInPixels, heightInPixels, static_cast<int32_t>(format), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IBuffer const& buffer, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, float dpi) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromBytesWithBufferAndDpi(*(void**)(&resourceCreator), *(void**)(&buffer), widthInPixels, heightInPixels, static_cast<int32_t>(format), dpi, &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromBytesWithBufferAndDpi(*(void**)(&resourceCreator), *(void**)(&buffer), widthInPixels, heightInPixels, static_cast<int32_t>(format), dpi, &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IBuffer const& buffer, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromBytesWithBufferAndDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&buffer), widthInPixels, heightInPixels, static_cast<int32_t>(format), dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromBytesWithBufferAndDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&buffer), widthInPixels, heightInPixels, static_cast<int32_t>(format), dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromColors(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Windows::UI::Color const> colors, int32_t widthInPixels, int32_t heightInPixels) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromColors(*(void**)(&resourceCreator), colors.size(), get_abi(colors), widthInPixels, heightInPixels, &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromColors(*(void**)(&resourceCreator), colors.size(), get_abi(colors), widthInPixels, heightInPixels, &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromColors(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Windows::UI::Color const> colors, int32_t widthInPixels, int32_t heightInPixels, float dpi) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromColorsWithDpi(*(void**)(&resourceCreator), colors.size(), get_abi(colors), widthInPixels, heightInPixels, dpi, &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromColorsWithDpi(*(void**)(&resourceCreator), colors.size(), get_abi(colors), widthInPixels, heightInPixels, dpi, &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromColors(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Windows::UI::Color const> colors, int32_t widthInPixels, int32_t heightInPixels, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromColorsWithDpiAndAlpha(*(void**)(&resourceCreator), colors.size(), get_abi(colors), widthInPixels, heightInPixels, dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromColorsWithDpiAndAlpha(*(void**)(&resourceCreator), colors.size(), get_abi(colors), widthInPixels, heightInPixels, dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::CreateFromSoftwareBitmap(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::Imaging::SoftwareBitmap const& sourceBitmap) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromSoftwareBitmap(*(void**)(&resourceCreator), *(void**)(&sourceBitmap), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromSoftwareBitmap(*(void**)(&resourceCreator), *(void**)(&sourceBitmap), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasBitmap{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromHstring(*(void**)(&resourceCreator), *(void**)(&fileName), &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromHstring(*(void**)(&resourceCreator), *(void**)(&fileName), &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName, float dpi) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromHstringWithDpi(*(void**)(&resourceCreator), *(void**)(&fileName), dpi, &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromHstringWithDpi(*(void**)(&resourceCreator), *(void**)(&fileName), dpi, &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromHstringWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&fileName), dpi, static_cast<int32_t>(alpha), &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromHstringWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&fileName), dpi, static_cast<int32_t>(alpha), &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromUri(*(void**)(&resourceCreator), *(void**)(&uri), &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromUri(*(void**)(&resourceCreator), *(void**)(&uri), &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri, float dpi) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromUriWithDpi(*(void**)(&resourceCreator), *(void**)(&uri), dpi, &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromUriWithDpi(*(void**)(&resourceCreator), *(void**)(&uri), dpi, &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromUriWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&uri), dpi, static_cast<int32_t>(alpha), &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromUriWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&uri), dpi, static_cast<int32_t>(alpha), &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromStream(*(void**)(&resourceCreator), *(void**)(&stream), &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromStream(*(void**)(&resourceCreator), *(void**)(&stream), &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, float dpi) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromStreamWithDpi(*(void**)(&resourceCreator), *(void**)(&stream), dpi, &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromStreamWithDpi(*(void**)(&resourceCreator), *(void**)(&stream), dpi, &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* canvasBitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromStreamWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&stream), dpi, static_cast<int32_t>(alpha), &canvasBitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromStreamWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&stream), dpi, static_cast<int32_t>(alpha), &canvasBitmap));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>{ canvasBitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasCommandList<D>::CreateDrawingSession() const
    {
        void* drawingSession{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasCommandList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasCommandList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasCommandList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateDrawingSession(&drawingSession));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasCommandList>**)this;
            check_hresult(_winrt_abi_type->CreateDrawingSession(&drawingSession));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession{ drawingSession, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasCommandList<D>::Device() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasCommandList>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasCommandList, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasCommandList>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Device(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasCommandList>**)this;
            check_hresult(_winrt_abi_type->get_Device(&value));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasCommandListFactory<D>::Create(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) const
    {
        void* commandList{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasCommandListFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasCommandListFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasCommandListFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Create(*(void**)(&resourceCreator), &commandList));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasCommandListFactory>**)this;
            check_hresult(_winrt_abi_type->Create(*(void**)(&resourceCreator), &commandList));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasCommandList{ commandList, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::ForceSoftwareRenderer() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_ForceSoftwareRenderer(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->get_ForceSoftwareRenderer(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::MaximumBitmapSizeInPixels() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaximumBitmapSizeInPixels(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->get_MaximumBitmapSizeInPixels(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::IsPixelFormatSupported(winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& pixelFormat) const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsPixelFormatSupported(static_cast<int32_t>(pixelFormat), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->IsPixelFormatSupported(static_cast<int32_t>(pixelFormat), &value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::IsBufferPrecisionSupported(winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision) const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsBufferPrecisionSupported(static_cast<int32_t>(bufferPrecision), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->IsBufferPrecisionSupported(static_cast<int32_t>(bufferPrecision), &value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::MaximumCacheSize() const
    {
        uint64_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_MaximumCacheSize(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->get_MaximumCacheSize(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::MaximumCacheSize(uint64_t value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_MaximumCacheSize(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->put_MaximumCacheSize(value));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::LowPriority() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_LowPriority(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->get_LowPriority(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::LowPriority(bool value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_LowPriority(value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->put_LowPriority(value));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::DeviceLost(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Graphics::Canvas::CanvasDevice, winrt::Windows::Foundation::IInspectable> const& value) const
    {
        winrt::event_token token{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->add_DeviceLost(*(void**)(&value), put_abi(token)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->add_DeviceLost(*(void**)(&value), put_abi(token)));
        }
        return token;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::DeviceLost(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Graphics::Canvas::CanvasDevice, winrt::Windows::Foundation::IInspectable> const& value) const
    {
        return impl::make_event_revoker<D, DeviceLost_revoker>(this, DeviceLost(value));
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::DeviceLost(winrt::event_token const& token) const noexcept
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            _winrt_abi_type->remove_DeviceLost(impl::bind_in(token));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            _winrt_abi_type->remove_DeviceLost(impl::bind_in(token));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::IsDeviceLost(int32_t hresult) const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsDeviceLost(hresult, &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->IsDeviceLost(hresult, &value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::RaiseDeviceLost() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->RaiseDeviceLost());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->RaiseDeviceLost());
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::Lock() const
    {
        void* lock{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Lock(&lock));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->Lock(&lock));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasLock{ lock, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::IsDeviceLost() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsDeviceLost2(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->IsDeviceLost2(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDevice<D>::GetDeviceLostReason() const
    {
        int32_t hresult{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDevice, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetDeviceLostReason(&hresult));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDevice>**)this;
            check_hresult(_winrt_abi_type->GetDeviceLostReason(&hresult));
        }
        return hresult;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDeviceFactory<D>::CreateWithForceSoftwareRendererOption(bool forceSoftwareRenderer) const
    {
        void* canvasDevice{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithForceSoftwareRendererOption(forceSoftwareRenderer, &canvasDevice));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithForceSoftwareRendererOption(forceSoftwareRenderer, &canvasDevice));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ canvasDevice, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDeviceStatics<D>::CreateFromDirect3D11Device(winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice const& direct3DDevice) const
    {
        void* canvasDevice{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11Device(*(void**)(&direct3DDevice), &canvasDevice));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11Device(*(void**)(&direct3DDevice), &canvasDevice));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ canvasDevice, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDeviceStatics<D>::GetSharedDevice() const
    {
        void* canvasDevice{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSharedDevice(&canvasDevice));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)this;
            check_hresult(_winrt_abi_type->GetSharedDevice(&canvasDevice));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ canvasDevice, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDeviceStatics<D>::GetSharedDevice(bool forceSoftwareRenderer) const
    {
        void* canvasDevice{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetSharedDeviceWithForceSoftwareRenderer(forceSoftwareRenderer, &canvasDevice));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)this;
            check_hresult(_winrt_abi_type->GetSharedDeviceWithForceSoftwareRenderer(forceSoftwareRenderer, &canvasDevice));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ canvasDevice, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDeviceStatics<D>::DebugLevel(winrt::Microsoft::Graphics::Canvas::CanvasDebugLevel const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_DebugLevel(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)this;
            check_hresult(_winrt_abi_type->put_DebugLevel(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDeviceStatics<D>::DebugLevel() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasDebugLevel value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_DebugLevel(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>**)this;
            check_hresult(_winrt_abi_type->get_DebugLevel(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Clear(winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Clear(impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->Clear(impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Clear(winrt::Windows::Foundation::Numerics::float4 const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ClearHdr(impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->ClearHdr(impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Flush() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Flush());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->Flush());
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtOrigin(*(void**)(&image)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtOrigin(*(void**)(&image)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Numerics::float2 const& offset) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtOffset(*(void**)(&image), impl::bind_in(offset)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtOffset(*(void**)(&image), impl::bind_in(offset)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, float x, float y) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtCoords(*(void**)(&image), x, y));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtCoords(*(void**)(&image), x, y));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Rect const& destinationRectangle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageToRect(*(void**)(&bitmap), impl::bind_in(destinationRectangle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageToRect(*(void**)(&bitmap), impl::bind_in(destinationRectangle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Rect const& sourceRectangle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRect(*(void**)(&image), impl::bind_in(offset), impl::bind_in(sourceRectangle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRect(*(void**)(&image), impl::bind_in(offset), impl::bind_in(sourceRectangle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, float x, float y, winrt::Windows::Foundation::Rect const& sourceRectangle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRect(*(void**)(&image), x, y, impl::bind_in(sourceRectangle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRect(*(void**)(&image), x, y, impl::bind_in(sourceRectangle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& destinationRectangle, winrt::Windows::Foundation::Rect const& sourceRectangle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRect(*(void**)(&image), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRect(*(void**)(&image), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRectAndOpacity(*(void**)(&image), impl::bind_in(offset), impl::bind_in(sourceRectangle), opacity));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRectAndOpacity(*(void**)(&image), impl::bind_in(offset), impl::bind_in(sourceRectangle), opacity));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, float x, float y, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRectAndOpacity(*(void**)(&image), x, y, impl::bind_in(sourceRectangle), opacity));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRectAndOpacity(*(void**)(&image), x, y, impl::bind_in(sourceRectangle), opacity));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& destinationRectangle, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRectAndOpacity(*(void**)(&image), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle), opacity));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRectAndOpacity(*(void**)(&image), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle), opacity));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolation(*(void**)(&image), impl::bind_in(offset), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolation(*(void**)(&image), impl::bind_in(offset), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, float x, float y, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolation(*(void**)(&image), x, y, impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolation(*(void**)(&image), x, y, impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& destinationRectangle, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRectAndOpacityAndInterpolation(*(void**)(&image), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRectAndOpacityAndInterpolation(*(void**)(&image), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation, winrt::Microsoft::Graphics::Canvas::CanvasComposite const& composite) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndComposite(*(void**)(&image), impl::bind_in(offset), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), static_cast<int32_t>(composite)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndComposite(*(void**)(&image), impl::bind_in(offset), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), static_cast<int32_t>(composite)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, float x, float y, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation, winrt::Microsoft::Graphics::Canvas::CanvasComposite const& composite) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndComposite(*(void**)(&image), x, y, impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), static_cast<int32_t>(composite)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndComposite(*(void**)(&image), x, y, impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), static_cast<int32_t>(composite)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& destinationRectangle, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation, winrt::Microsoft::Graphics::Canvas::CanvasComposite const& composite) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndComposite(*(void**)(&image), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), static_cast<int32_t>(composite)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndComposite(*(void**)(&image), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), static_cast<int32_t>(composite)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation, winrt::Windows::Foundation::Numerics::float4x4 const& perspective) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndPerspective(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), impl::bind_in(perspective)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndPerspective(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), impl::bind_in(perspective)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, float x, float y, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation, winrt::Windows::Foundation::Numerics::float4x4 const& perspective) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndPerspective(*(void**)(&bitmap), x, y, impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), impl::bind_in(perspective)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndPerspective(*(void**)(&bitmap), x, y, impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), impl::bind_in(perspective)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawImage(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Rect const& destinationRectangle, winrt::Windows::Foundation::Rect const& sourceRectangle, float opacity, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation, winrt::Windows::Foundation::Numerics::float4x4 const& perspective) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndPerspective(*(void**)(&bitmap), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), impl::bind_in(perspective)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndPerspective(*(void**)(&bitmap), impl::bind_in(destinationRectangle), impl::bind_in(sourceRectangle), opacity, static_cast<int32_t>(interpolation), impl::bind_in(perspective)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(winrt::Windows::Foundation::Numerics::float2 const& point0, winrt::Windows::Foundation::Numerics::float2 const& point1, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineWithBrush(impl::bind_in(point0), impl::bind_in(point1), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineWithBrush(impl::bind_in(point0), impl::bind_in(point1), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(float x0, float y0, float x1, float y1, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithBrush(x0, y0, x1, y1, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithBrush(x0, y0, x1, y1, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(winrt::Windows::Foundation::Numerics::float2 const& point0, winrt::Windows::Foundation::Numerics::float2 const& point1, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineWithColor(impl::bind_in(point0), impl::bind_in(point1), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineWithColor(impl::bind_in(point0), impl::bind_in(point1), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(float x0, float y0, float x1, float y1, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithColor(x0, y0, x1, y1, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithColor(x0, y0, x1, y1, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(winrt::Windows::Foundation::Numerics::float2 const& point0, winrt::Windows::Foundation::Numerics::float2 const& point1, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineWithBrushAndStrokeWidth(impl::bind_in(point0), impl::bind_in(point1), *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineWithBrushAndStrokeWidth(impl::bind_in(point0), impl::bind_in(point1), *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(float x0, float y0, float x1, float y1, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithBrushAndStrokeWidth(x0, y0, x1, y1, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithBrushAndStrokeWidth(x0, y0, x1, y1, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(winrt::Windows::Foundation::Numerics::float2 const& point0, winrt::Windows::Foundation::Numerics::float2 const& point1, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineWithColorAndStrokeWidth(impl::bind_in(point0), impl::bind_in(point1), impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineWithColorAndStrokeWidth(impl::bind_in(point0), impl::bind_in(point1), impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(float x0, float y0, float x1, float y1, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithColorAndStrokeWidth(x0, y0, x1, y1, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithColorAndStrokeWidth(x0, y0, x1, y1, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(winrt::Windows::Foundation::Numerics::float2 const& point0, winrt::Windows::Foundation::Numerics::float2 const& point1, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(point0), impl::bind_in(point1), *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(point0), impl::bind_in(point1), *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(float x0, float y0, float x1, float y1, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x0, y0, x1, y1, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x0, y0, x1, y1, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(winrt::Windows::Foundation::Numerics::float2 const& point0, winrt::Windows::Foundation::Numerics::float2 const& point1, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(point0), impl::bind_in(point1), impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(point0), impl::bind_in(point1), impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawLine(float x0, float y0, float x1, float y1, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x0, y0, x1, y1, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawLineAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x0, y0, x1, y1, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleWithBrush(impl::bind_in(rect), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleWithBrush(impl::bind_in(rect), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(float x, float y, float w, float h, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithBrush(x, y, w, h, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithBrush(x, y, w, h, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleWithColor(impl::bind_in(rect), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleWithColor(impl::bind_in(rect), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(float x, float y, float w, float h, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithColor(x, y, w, h, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithColor(x, y, w, h, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleWithBrushAndStrokeWidth(impl::bind_in(rect), *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleWithBrushAndStrokeWidth(impl::bind_in(rect), *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(float x, float y, float w, float h, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithBrushAndStrokeWidth(x, y, w, h, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithBrushAndStrokeWidth(x, y, w, h, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleWithColorAndStrokeWidth(impl::bind_in(rect), impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleWithColorAndStrokeWidth(impl::bind_in(rect), impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(float x, float y, float w, float h, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithColorAndStrokeWidth(x, y, w, h, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithColorAndStrokeWidth(x, y, w, h, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(rect), *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(rect), *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(float x, float y, float w, float h, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, w, h, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, w, h, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(rect), impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(rect), impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRectangle(float x, float y, float w, float h, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, w, h, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, w, h, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRectangleWithBrush(impl::bind_in(rect), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRectangleWithBrush(impl::bind_in(rect), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRectangle(float x, float y, float w, float h, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRectangleAtCoordsWithBrush(x, y, w, h, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRectangleAtCoordsWithBrush(x, y, w, h, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRectangleWithColor(impl::bind_in(rect), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRectangleWithColor(impl::bind_in(rect), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRectangle(float x, float y, float w, float h, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRectangleAtCoordsWithColor(x, y, w, h, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRectangleAtCoordsWithColor(x, y, w, h, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRectangle(winrt::Windows::Foundation::Rect const& rect, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRectangleWithBrushAndOpacityBrush(impl::bind_in(rect), *(void**)(&brush), *(void**)(&opacityBrush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRectangleWithBrushAndOpacityBrush(impl::bind_in(rect), *(void**)(&brush), *(void**)(&opacityBrush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRectangle(float x, float y, float w, float h, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRectangleAtCoordsWithBrushAndOpacityBrush(x, y, w, h, *(void**)(&brush), *(void**)(&opacityBrush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRectangleAtCoordsWithBrushAndOpacityBrush(x, y, w, h, *(void**)(&brush), *(void**)(&opacityBrush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithBrush(impl::bind_in(rect), radiusX, radiusY, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithBrush(impl::bind_in(rect), radiusX, radiusY, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(float x, float y, float w, float h, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithBrush(x, y, w, h, radiusX, radiusY, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithBrush(x, y, w, h, radiusX, radiusY, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithColor(impl::bind_in(rect), radiusX, radiusY, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithColor(impl::bind_in(rect), radiusX, radiusY, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(float x, float y, float w, float h, float radiusX, float radiusY, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithColor(x, y, w, h, radiusX, radiusY, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithColor(x, y, w, h, radiusX, radiusY, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithBrushAndStrokeWidth(impl::bind_in(rect), radiusX, radiusY, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithBrushAndStrokeWidth(impl::bind_in(rect), radiusX, radiusY, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(float x, float y, float w, float h, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidth(x, y, w, h, radiusX, radiusY, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidth(x, y, w, h, radiusX, radiusY, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithColorAndStrokeWidth(impl::bind_in(rect), radiusX, radiusY, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithColorAndStrokeWidth(impl::bind_in(rect), radiusX, radiusY, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(float x, float y, float w, float h, float radiusX, float radiusY, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithColorAndStrokeWidth(x, y, w, h, radiusX, radiusY, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithColorAndStrokeWidth(x, y, w, h, radiusX, radiusY, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(rect), radiusX, radiusY, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(rect), radiusX, radiusY, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(float x, float y, float w, float h, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, w, h, radiusX, radiusY, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, w, h, radiusX, radiusY, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(rect), radiusX, radiusY, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(rect), radiusX, radiusY, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawRoundedRectangle(float x, float y, float w, float h, float radiusX, float radiusY, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, w, h, radiusX, radiusY, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawRoundedRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, w, h, radiusX, radiusY, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRoundedRectangle(winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRoundedRectangleWithBrush(impl::bind_in(rect), radiusX, radiusY, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRoundedRectangleWithBrush(impl::bind_in(rect), radiusX, radiusY, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRoundedRectangle(float x, float y, float w, float h, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRoundedRectangleAtCoordsWithBrush(x, y, w, h, radiusX, radiusY, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRoundedRectangleAtCoordsWithBrush(x, y, w, h, radiusX, radiusY, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRoundedRectangle(winrt::Windows::Foundation::Rect const& rect, float radiusX, float radiusY, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRoundedRectangleWithColor(impl::bind_in(rect), radiusX, radiusY, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRoundedRectangleWithColor(impl::bind_in(rect), radiusX, radiusY, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillRoundedRectangle(float x, float y, float w, float h, float radiusX, float radiusY, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillRoundedRectangleAtCoordsWithColor(x, y, w, h, radiusX, radiusY, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillRoundedRectangleAtCoordsWithColor(x, y, w, h, radiusX, radiusY, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseWithBrush(impl::bind_in(centerPoint), radiusX, radiusY, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseWithBrush(impl::bind_in(centerPoint), radiusX, radiusY, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(float x, float y, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithBrush(x, y, radiusX, radiusY, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithBrush(x, y, radiusX, radiusY, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseWithColor(impl::bind_in(centerPoint), radiusX, radiusY, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseWithColor(impl::bind_in(centerPoint), radiusX, radiusY, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(float x, float y, float radiusX, float radiusY, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithColor(x, y, radiusX, radiusY, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithColor(x, y, radiusX, radiusY, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseWithBrushAndStrokeWidth(impl::bind_in(centerPoint), radiusX, radiusY, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseWithBrushAndStrokeWidth(impl::bind_in(centerPoint), radiusX, radiusY, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(float x, float y, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithBrushAndStrokeWidth(x, y, radiusX, radiusY, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithBrushAndStrokeWidth(x, y, radiusX, radiusY, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseWithColorAndStrokeWidth(impl::bind_in(centerPoint), radiusX, radiusY, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseWithColorAndStrokeWidth(impl::bind_in(centerPoint), radiusX, radiusY, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(float x, float y, float radiusX, float radiusY, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithColorAndStrokeWidth(x, y, radiusX, radiusY, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithColorAndStrokeWidth(x, y, radiusX, radiusY, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(centerPoint), radiusX, radiusY, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(centerPoint), radiusX, radiusY, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(float x, float y, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, radiusX, radiusY, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, radiusX, radiusY, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(centerPoint), radiusX, radiusY, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(centerPoint), radiusX, radiusY, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawEllipse(float x, float y, float radiusX, float radiusY, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, radiusX, radiusY, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawEllipseAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, radiusX, radiusY, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillEllipse(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillEllipseWithBrush(impl::bind_in(centerPoint), radiusX, radiusY, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillEllipseWithBrush(impl::bind_in(centerPoint), radiusX, radiusY, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillEllipse(float x, float y, float radiusX, float radiusY, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillEllipseAtCoordsWithBrush(x, y, radiusX, radiusY, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillEllipseAtCoordsWithBrush(x, y, radiusX, radiusY, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillEllipse(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radiusX, float radiusY, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillEllipseWithColor(impl::bind_in(centerPoint), radiusX, radiusY, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillEllipseWithColor(impl::bind_in(centerPoint), radiusX, radiusY, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillEllipse(float x, float y, float radiusX, float radiusY, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillEllipseAtCoordsWithColor(x, y, radiusX, radiusY, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillEllipseAtCoordsWithColor(x, y, radiusX, radiusY, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleWithBrush(impl::bind_in(centerPoint), radius, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleWithBrush(impl::bind_in(centerPoint), radius, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(float x, float y, float radius, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithBrush(x, y, radius, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithBrush(x, y, radius, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleWithColor(impl::bind_in(centerPoint), radius, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleWithColor(impl::bind_in(centerPoint), radius, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(float x, float y, float radius, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithColor(x, y, radius, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithColor(x, y, radius, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleWithBrushAndStrokeWidth(impl::bind_in(centerPoint), radius, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleWithBrushAndStrokeWidth(impl::bind_in(centerPoint), radius, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(float x, float y, float radius, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithBrushAndStrokeWidth(x, y, radius, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithBrushAndStrokeWidth(x, y, radius, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleWithColorAndStrokeWidth(impl::bind_in(centerPoint), radius, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleWithColorAndStrokeWidth(impl::bind_in(centerPoint), radius, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(float x, float y, float radius, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithColorAndStrokeWidth(x, y, radius, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithColorAndStrokeWidth(x, y, radius, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(centerPoint), radius, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleWithBrushAndStrokeWidthAndStrokeStyle(impl::bind_in(centerPoint), radius, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(float x, float y, float radius, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, radius, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, radius, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(centerPoint), radius, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleWithColorAndStrokeWidthAndStrokeStyle(impl::bind_in(centerPoint), radius, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCircle(float x, float y, float radius, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, radius, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCircleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, radius, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillCircle(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillCircleWithBrush(impl::bind_in(centerPoint), radius, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillCircleWithBrush(impl::bind_in(centerPoint), radius, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillCircle(float x, float y, float radius, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillCircleAtCoordsWithBrush(x, y, radius, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillCircleAtCoordsWithBrush(x, y, radius, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillCircle(winrt::Windows::Foundation::Numerics::float2 const& centerPoint, float radius, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillCircleWithColor(impl::bind_in(centerPoint), radius, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillCircleWithColor(impl::bind_in(centerPoint), radius, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillCircle(float x, float y, float radius, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillCircleAtCoordsWithColor(x, y, radius, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillCircleAtCoordsWithColor(x, y, radius, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtPointWithColor(*(void**)(&text), impl::bind_in(point), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtPointWithColor(*(void**)(&text), impl::bind_in(point), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, float x, float y, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtPointCoordsWithColor(*(void**)(&text), x, y, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtPointCoordsWithColor(*(void**)(&text), x, y, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const& format) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtPointWithBrushAndFormat(*(void**)(&text), impl::bind_in(point), *(void**)(&brush), *(void**)(&format)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtPointWithBrushAndFormat(*(void**)(&text), impl::bind_in(point), *(void**)(&brush), *(void**)(&format)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, winrt::Windows::Foundation::Rect const& rectangle, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const& format) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtRectWithBrushAndFormat(*(void**)(&text), impl::bind_in(rectangle), *(void**)(&brush), *(void**)(&format)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtRectWithBrushAndFormat(*(void**)(&text), impl::bind_in(rectangle), *(void**)(&brush), *(void**)(&format)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, float x, float y, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const& format) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtPointCoordsWithBrushAndFormat(*(void**)(&text), x, y, *(void**)(&brush), *(void**)(&format)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtPointCoordsWithBrushAndFormat(*(void**)(&text), x, y, *(void**)(&brush), *(void**)(&format)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, float x, float y, float w, float h, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const& format) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtRectCoordsWithBrushAndFormat(*(void**)(&text), x, y, w, h, *(void**)(&brush), *(void**)(&format)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtRectCoordsWithBrushAndFormat(*(void**)(&text), x, y, w, h, *(void**)(&brush), *(void**)(&format)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Windows::UI::Color const& color, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const& format) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtPointWithColorAndFormat(*(void**)(&text), impl::bind_in(point), impl::bind_in(color), *(void**)(&format)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtPointWithColorAndFormat(*(void**)(&text), impl::bind_in(point), impl::bind_in(color), *(void**)(&format)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, winrt::Windows::Foundation::Rect const& rectangle, winrt::Windows::UI::Color const& color, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const& format) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtRectWithColorAndFormat(*(void**)(&text), impl::bind_in(rectangle), impl::bind_in(color), *(void**)(&format)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtRectWithColorAndFormat(*(void**)(&text), impl::bind_in(rectangle), impl::bind_in(color), *(void**)(&format)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, float x, float y, winrt::Windows::UI::Color const& color, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const& format) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtPointCoordsWithColorAndFormat(*(void**)(&text), x, y, impl::bind_in(color), *(void**)(&format)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtPointCoordsWithColorAndFormat(*(void**)(&text), x, y, impl::bind_in(color), *(void**)(&format)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawText(param::hstring const& text, float x, float y, float w, float h, winrt::Windows::UI::Color const& color, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const& format) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextAtRectCoordsWithColorAndFormat(*(void**)(&text), x, y, w, h, impl::bind_in(color), *(void**)(&format)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextAtRectCoordsWithColorAndFormat(*(void**)(&text), x, y, w, h, impl::bind_in(color), *(void**)(&format)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryWithBrush(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryWithBrush(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryWithColor(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryWithColor(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithBrush(*(void**)(&geometry), x, y, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithBrush(*(void**)(&geometry), x, y, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithColor(*(void**)(&geometry), x, y, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithColor(*(void**)(&geometry), x, y, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithBrush(*(void**)(&geometry), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithBrush(*(void**)(&geometry), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithColor(*(void**)(&geometry), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithColor(*(void**)(&geometry), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryWithBrushAndStrokeWidth(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryWithBrushAndStrokeWidth(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryWithColorAndStrokeWidth(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryWithColorAndStrokeWidth(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithBrushAndStrokeWidth(*(void**)(&geometry), x, y, *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithBrushAndStrokeWidth(*(void**)(&geometry), x, y, *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithColorAndStrokeWidth(*(void**)(&geometry), x, y, impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithColorAndStrokeWidth(*(void**)(&geometry), x, y, impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithBrushAndStrokeWidth(*(void**)(&geometry), *(void**)(&brush), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithBrushAndStrokeWidth(*(void**)(&geometry), *(void**)(&brush), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::UI::Color const& color, float strokeWidth) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithColorAndStrokeWidth(*(void**)(&geometry), impl::bind_in(color), strokeWidth));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithColorAndStrokeWidth(*(void**)(&geometry), impl::bind_in(color), strokeWidth));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryWithBrushAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryWithBrushAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryWithColorAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryWithColorAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), x, y, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), x, y, *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithColorAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), x, y, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtCoordsWithColorAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), x, y, impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithBrushAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithBrushAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), *(void**)(&brush), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::UI::Color const& color, float strokeWidth, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const& strokeStyle) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithColorAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGeometryAtOriginWithColorAndStrokeWidthAndStrokeStyle(*(void**)(&geometry), impl::bind_in(color), strokeWidth, *(void**)(&strokeStyle)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryWithBrush(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryWithBrush(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryWithBrushAndOpacityBrush(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush), *(void**)(&opacityBrush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryWithBrushAndOpacityBrush(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush), *(void**)(&opacityBrush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryWithColor(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryWithColor(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryAtCoordsWithBrush(*(void**)(&geometry), x, y, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryAtCoordsWithBrush(*(void**)(&geometry), x, y, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryAtCoordsWithBrushAndOpacityBrush(*(void**)(&geometry), x, y, *(void**)(&brush), *(void**)(&opacityBrush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryAtCoordsWithBrushAndOpacityBrush(*(void**)(&geometry), x, y, *(void**)(&brush), *(void**)(&opacityBrush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, float x, float y, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryAtCoordsWithColor(*(void**)(&geometry), x, y, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryAtCoordsWithColor(*(void**)(&geometry), x, y, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryAtOriginWithBrush(*(void**)(&geometry), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryAtOriginWithBrush(*(void**)(&geometry), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryAtOriginWithBrushAndOpacityBrush(*(void**)(&geometry), *(void**)(&brush), *(void**)(&opacityBrush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryAtOriginWithBrushAndOpacityBrush(*(void**)(&geometry), *(void**)(&brush), *(void**)(&opacityBrush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::FillGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& geometry, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->FillGeometryAtOriginWithColor(*(void**)(&geometry), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->FillGeometryAtOriginWithColor(*(void**)(&geometry), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCachedGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCachedGeometryWithBrush(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCachedGeometryWithBrush(*(void**)(&geometry), impl::bind_in(offset), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCachedGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const& geometry, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCachedGeometryWithColor(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCachedGeometryWithColor(*(void**)(&geometry), impl::bind_in(offset), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCachedGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const& geometry, float x, float y, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCachedGeometryAtCoordsWithBrush(*(void**)(&geometry), x, y, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCachedGeometryAtCoordsWithBrush(*(void**)(&geometry), x, y, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCachedGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const& geometry, float x, float y, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCachedGeometryAtCoordsWithColor(*(void**)(&geometry), x, y, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCachedGeometryAtCoordsWithColor(*(void**)(&geometry), x, y, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCachedGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const& geometry, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCachedGeometryAtOriginWithBrush(*(void**)(&geometry), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCachedGeometryAtOriginWithBrush(*(void**)(&geometry), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawCachedGeometry(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const& geometry, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawCachedGeometryAtOriginWithColor(*(void**)(&geometry), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawCachedGeometryAtOriginWithColor(*(void**)(&geometry), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawTextLayout(winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const& textLayout, winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextLayoutWithBrush(*(void**)(&textLayout), impl::bind_in(point), *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextLayoutWithBrush(*(void**)(&textLayout), impl::bind_in(point), *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawTextLayout(winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const& textLayout, float x, float y, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextLayoutAtCoordsWithBrush(*(void**)(&textLayout), x, y, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextLayoutAtCoordsWithBrush(*(void**)(&textLayout), x, y, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawTextLayout(winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const& textLayout, winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextLayoutWithColor(*(void**)(&textLayout), impl::bind_in(point), impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextLayoutWithColor(*(void**)(&textLayout), impl::bind_in(point), impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawTextLayout(winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const& textLayout, float x, float y, winrt::Windows::UI::Color const& color) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawTextLayoutAtCoordsWithColor(*(void**)(&textLayout), x, y, impl::bind_in(color)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawTextLayoutAtCoordsWithColor(*(void**)(&textLayout), x, y, impl::bind_in(color)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGradientMesh(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh const& gradientMesh) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGradientMeshAtOrigin(*(void**)(&gradientMesh)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGradientMeshAtOrigin(*(void**)(&gradientMesh)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGradientMesh(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh const& gradientMesh, winrt::Windows::Foundation::Numerics::float2 const& point) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGradientMesh(*(void**)(&gradientMesh), impl::bind_in(point)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGradientMesh(*(void**)(&gradientMesh), impl::bind_in(point)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGradientMesh(winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh const& gradientMesh, float x, float y) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGradientMeshAtCoords(*(void**)(&gradientMesh), x, y));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGradientMeshAtCoords(*(void**)(&gradientMesh), x, y));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawSvg(winrt::Microsoft::Graphics::Canvas::Svg::CanvasSvgDocument const& svgDocument, winrt::Windows::Foundation::Size const& viewportSize) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawSvgAtOrigin(*(void**)(&svgDocument), impl::bind_in(viewportSize)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawSvgAtOrigin(*(void**)(&svgDocument), impl::bind_in(viewportSize)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawSvg(winrt::Microsoft::Graphics::Canvas::Svg::CanvasSvgDocument const& svgDocument, winrt::Windows::Foundation::Size const& viewportSize, winrt::Windows::Foundation::Numerics::float2 const& point) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawSvgAtPoint(*(void**)(&svgDocument), impl::bind_in(viewportSize), impl::bind_in(point)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawSvgAtPoint(*(void**)(&svgDocument), impl::bind_in(viewportSize), impl::bind_in(point)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawSvg(winrt::Microsoft::Graphics::Canvas::Svg::CanvasSvgDocument const& svgDocument, winrt::Windows::Foundation::Size const& viewportSize, float x, float y) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawSvgAtCoords(*(void**)(&svgDocument), impl::bind_in(viewportSize), x, y));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawSvgAtCoords(*(void**)(&svgDocument), impl::bind_in(viewportSize), x, y));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Antialiasing() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasAntialiasing value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Antialiasing(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->get_Antialiasing(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Antialiasing(winrt::Microsoft::Graphics::Canvas::CanvasAntialiasing const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Antialiasing(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->put_Antialiasing(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Blend() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasBlend value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Blend(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->get_Blend(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Blend(winrt::Microsoft::Graphics::Canvas::CanvasBlend const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Blend(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->put_Blend(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::TextAntialiasing() const
    {
        winrt::Microsoft::Graphics::Canvas::Text::CanvasTextAntialiasing value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TextAntialiasing(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->get_TextAntialiasing(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::TextAntialiasing(winrt::Microsoft::Graphics::Canvas::Text::CanvasTextAntialiasing const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TextAntialiasing(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->put_TextAntialiasing(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::TextRenderingParameters() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TextRenderingParameters(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->get_TextRenderingParameters(&value));
        }
        return winrt::Microsoft::Graphics::Canvas::Text::CanvasTextRenderingParameters{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::TextRenderingParameters(winrt::Microsoft::Graphics::Canvas::Text::CanvasTextRenderingParameters const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TextRenderingParameters(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->put_TextRenderingParameters(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Transform() const
    {
        winrt::Windows::Foundation::Numerics::float3x2 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Transform(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->get_Transform(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Transform(winrt::Windows::Foundation::Numerics::float3x2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Transform(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->put_Transform(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Units() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasUnits value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Units(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->get_Units(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::Units(winrt::Microsoft::Graphics::Canvas::CanvasUnits const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Units(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->put_Units(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::EffectBufferPrecision() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EffectBufferPrecision(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->get_EffectBufferPrecision(&value));
        }
        return winrt::Windows::Foundation::IReference<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::EffectBufferPrecision(winrt::Windows::Foundation::IReference<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision> const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_EffectBufferPrecision(*(void**)(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->put_EffectBufferPrecision(*(void**)(&value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::EffectTileSize() const
    {
        winrt::Windows::Graphics::Imaging::BitmapSize value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_EffectTileSize(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->get_EffectTileSize(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::EffectTileSize(winrt::Windows::Graphics::Imaging::BitmapSize const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_EffectTileSize(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->put_EffectTileSize(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(float opacity) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacity(opacity, &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacity(opacity, &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityBrush(*(void**)(&opacityBrush), &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityBrush(*(void**)(&opacityBrush), &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(float opacity, winrt::Windows::Foundation::Rect const& clipRectangle) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityAndClipRectangle(opacity, impl::bind_in(clipRectangle), &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityAndClipRectangle(opacity, impl::bind_in(clipRectangle), &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush, winrt::Windows::Foundation::Rect const& clipRectangle) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityBrushAndClipRectangle(*(void**)(&opacityBrush), impl::bind_in(clipRectangle), &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityBrushAndClipRectangle(*(void**)(&opacityBrush), impl::bind_in(clipRectangle), &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(float opacity, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& clipGeometry) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityAndClipGeometry(opacity, *(void**)(&clipGeometry), &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityAndClipGeometry(opacity, *(void**)(&clipGeometry), &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& clipGeometry) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityBrushAndClipGeometry(*(void**)(&opacityBrush), *(void**)(&clipGeometry), &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityBrushAndClipGeometry(*(void**)(&opacityBrush), *(void**)(&clipGeometry), &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(float opacity, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& clipGeometry, winrt::Windows::Foundation::Numerics::float3x2 const& geometryTransform) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityAndClipGeometryAndTransform(opacity, *(void**)(&clipGeometry), impl::bind_in(geometryTransform), &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityAndClipGeometryAndTransform(opacity, *(void**)(&clipGeometry), impl::bind_in(geometryTransform), &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& clipGeometry, winrt::Windows::Foundation::Numerics::float3x2 const& geometryTransform) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityBrushAndClipGeometryAndTransform(*(void**)(&opacityBrush), *(void**)(&clipGeometry), impl::bind_in(geometryTransform), &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithOpacityBrushAndClipGeometryAndTransform(*(void**)(&opacityBrush), *(void**)(&clipGeometry), impl::bind_in(geometryTransform), &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateLayer(float opacity, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& opacityBrush, winrt::Windows::Foundation::Rect const& clipRectangle, winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const& clipGeometry, winrt::Windows::Foundation::Numerics::float3x2 const& geometryTransform, winrt::Microsoft::Graphics::Canvas::CanvasLayerOptions const& options) const
    {
        void* layer{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateLayerWithAllOptions(opacity, *(void**)(&opacityBrush), impl::bind_in(clipRectangle), *(void**)(&clipGeometry), impl::bind_in(geometryTransform), static_cast<uint32_t>(options), &layer));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateLayerWithAllOptions(opacity, *(void**)(&opacityBrush), impl::bind_in(clipRectangle), *(void**)(&clipGeometry), impl::bind_in(geometryTransform), static_cast<uint32_t>(options), &layer));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer{ layer, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGlyphRun(winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const& fontFace, float fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const> glyphs, bool isSideways, uint32_t bidiLevel, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGlyphRun(impl::bind_in(point), *(void**)(&fontFace), fontSize, glyphs.size(), get_abi(glyphs), isSideways, bidiLevel, *(void**)(&brush)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGlyphRun(impl::bind_in(point), *(void**)(&fontFace), fontSize, glyphs.size(), get_abi(glyphs), isSideways, bidiLevel, *(void**)(&brush)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGlyphRun(winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const& fontFace, float fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const> glyphs, bool isSideways, uint32_t bidiLevel, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const& measuringMode) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGlyphRunWithMeasuringMode(impl::bind_in(point), *(void**)(&fontFace), fontSize, glyphs.size(), get_abi(glyphs), isSideways, bidiLevel, *(void**)(&brush), static_cast<int32_t>(measuringMode)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGlyphRunWithMeasuringMode(impl::bind_in(point), *(void**)(&fontFace), fontSize, glyphs.size(), get_abi(glyphs), isSideways, bidiLevel, *(void**)(&brush), static_cast<int32_t>(measuringMode)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::DrawGlyphRun(winrt::Windows::Foundation::Numerics::float2 const& point, winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const& fontFace, float fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const> glyphs, bool isSideways, uint32_t bidiLevel, winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const& brush, winrt::Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const& measuringMode, param::hstring const& localeName, param::hstring const& textString, array_view<int32_t const> clusterMapIndices, uint32_t textPosition) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawGlyphRunWithMeasuringModeAndDescription(impl::bind_in(point), *(void**)(&fontFace), fontSize, glyphs.size(), get_abi(glyphs), isSideways, bidiLevel, *(void**)(&brush), static_cast<int32_t>(measuringMode), *(void**)(&localeName), *(void**)(&textString), clusterMapIndices.size(), get_abi(clusterMapIndices), textPosition));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->DrawGlyphRunWithMeasuringModeAndDescription(impl::bind_in(point), *(void**)(&fontFace), fontSize, glyphs.size(), get_abi(glyphs), isSideways, bidiLevel, *(void**)(&brush), static_cast<int32_t>(measuringMode), *(void**)(&localeName), *(void**)(&textString), clusterMapIndices.size(), get_abi(clusterMapIndices), textPosition));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateSpriteBatch() const
    {
        void* spriteBatch{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateSpriteBatch(&spriteBatch));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateSpriteBatch(&spriteBatch));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch{ spriteBatch, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateSpriteBatch(winrt::Microsoft::Graphics::Canvas::CanvasSpriteSortMode const& sortMode) const
    {
        void* spriteBatch{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateSpriteBatchWithSortMode(static_cast<int32_t>(sortMode), &spriteBatch));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateSpriteBatchWithSortMode(static_cast<int32_t>(sortMode), &spriteBatch));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch{ spriteBatch, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateSpriteBatch(winrt::Microsoft::Graphics::Canvas::CanvasSpriteSortMode const& sortMode, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation) const
    {
        void* spriteBatch{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateSpriteBatchWithSortModeAndInterpolation(static_cast<int32_t>(sortMode), static_cast<int32_t>(interpolation), &spriteBatch));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateSpriteBatchWithSortModeAndInterpolation(static_cast<int32_t>(sortMode), static_cast<int32_t>(interpolation), &spriteBatch));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch{ spriteBatch, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasDrawingSession<D>::CreateSpriteBatch(winrt::Microsoft::Graphics::Canvas::CanvasSpriteSortMode const& sortMode, winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const& interpolation, winrt::Microsoft::Graphics::Canvas::CanvasSpriteOptions const& options) const
    {
        void* spriteBatch{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateSpriteBatchWithSortModeAndInterpolationAndOptions(static_cast<int32_t>(sortMode), static_cast<int32_t>(interpolation), static_cast<uint32_t>(options), &spriteBatch));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>**)this;
            check_hresult(_winrt_abi_type->CreateSpriteBatchWithSortModeAndInterpolationAndOptions(static_cast<int32_t>(sortMode), static_cast<int32_t>(interpolation), static_cast<uint32_t>(options), &spriteBatch));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch{ spriteBatch, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasImage<D>::GetBounds(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) const
    {
        winrt::Windows::Foundation::Rect bounds{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasImage>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasImage, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImage>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetBounds(*(void**)(&resourceCreator), put_abi(bounds)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImage>**)this;
            check_hresult(_winrt_abi_type->GetBounds(*(void**)(&resourceCreator), put_abi(bounds)));
        }
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasImage<D>::GetBounds(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Numerics::float3x2 const& transform) const
    {
        winrt::Windows::Foundation::Rect bounds{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasImage>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasImage, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImage>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->GetBoundsWithTransform(*(void**)(&resourceCreator), impl::bind_in(transform), put_abi(bounds)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImage>**)this;
            check_hresult(_winrt_abi_type->GetBoundsWithTransform(*(void**)(&resourceCreator), impl::bind_in(transform), put_abi(bounds)));
        }
        return bounds;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasImageStatics<D>::SaveAsync(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& sourceRectangle, float dpi, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat) const
    {
        void* action{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveAsync(*(void**)(&image), impl::bind_in(sourceRectangle), dpi, *(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(fileFormat), &action));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)this;
            check_hresult(_winrt_abi_type->SaveAsync(*(void**)(&image), impl::bind_in(sourceRectangle), dpi, *(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(fileFormat), &action));
        }
        return winrt::Windows::Foundation::IAsyncAction{ action, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasImageStatics<D>::SaveAsync(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& sourceRectangle, float dpi, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat, float quality) const
    {
        void* action{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveWithQualityAsync(*(void**)(&image), impl::bind_in(sourceRectangle), dpi, *(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(fileFormat), quality, &action));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)this;
            check_hresult(_winrt_abi_type->SaveWithQualityAsync(*(void**)(&image), impl::bind_in(sourceRectangle), dpi, *(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(fileFormat), quality, &action));
        }
        return winrt::Windows::Foundation::IAsyncAction{ action, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasImageStatics<D>::SaveAsync(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& sourceRectangle, float dpi, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat, float quality, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision) const
    {
        void* action{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->SaveWithQualityAndBufferPrecisionAsync(*(void**)(&image), impl::bind_in(sourceRectangle), dpi, *(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(fileFormat), quality, static_cast<int32_t>(bufferPrecision), &action));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)this;
            check_hresult(_winrt_abi_type->SaveWithQualityAndBufferPrecisionAsync(*(void**)(&image), impl::bind_in(sourceRectangle), dpi, *(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(fileFormat), quality, static_cast<int32_t>(bufferPrecision), &action));
        }
        return winrt::Windows::Foundation::IAsyncAction{ action, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasImageStatics<D>::ComputeHistogram(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& sourceRectangle, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Microsoft::Graphics::Canvas::Effects::EffectChannelSelect const& channelSelect, int32_t numberOfBins) const
    {
        uint32_t valueElements_impl_size{};
        float* valueElements{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ComputeHistogram(*(void**)(&image), impl::bind_in(sourceRectangle), *(void**)(&resourceCreator), static_cast<int32_t>(channelSelect), numberOfBins, &valueElements_impl_size, &valueElements));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)this;
            check_hresult(_winrt_abi_type->ComputeHistogram(*(void**)(&image), impl::bind_in(sourceRectangle), *(void**)(&resourceCreator), static_cast<int32_t>(channelSelect), numberOfBins, &valueElements_impl_size, &valueElements));
        }
        return com_array<float>{ valueElements, valueElements_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasImageStatics<D>::IsHistogramSupported(winrt::Microsoft::Graphics::Canvas::CanvasDevice const& device) const
    {
        bool result{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsHistogramSupported(*(void**)(&device), &result));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>**)this;
            check_hresult(_winrt_abi_type->IsHistogramSupported(*(void**)(&device), &result));
        }
        return result;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasRenderTarget<D>::CreateDrawingSession() const
    {
        void* drawingSession{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTarget>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTarget, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTarget>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateDrawingSession(&drawingSession));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTarget>**)this;
            check_hresult(_winrt_abi_type->CreateDrawingSession(&drawingSession));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession{ drawingSession, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasRenderTargetFactory<D>::CreateWithSize(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const& resourceCreator, winrt::Windows::Foundation::Size const& size) const
    {
        void* renderTarget{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithSize(*(void**)(&resourceCreator), impl::bind_in(size), &renderTarget));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithSize(*(void**)(&resourceCreator), impl::bind_in(size), &renderTarget));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget{ renderTarget, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasRenderTargetFactory<D>::CreateWithWidthAndHeight(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const& resourceCreator, float width, float height) const
    {
        void* renderTarget{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeight(*(void**)(&resourceCreator), width, height, &renderTarget));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeight(*(void**)(&resourceCreator), width, height, &renderTarget));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget{ renderTarget, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasRenderTargetFactory<D>::CreateWithWidthAndHeightAndDpi(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float width, float height, float dpi) const
    {
        void* renderTarget{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeightAndDpi(*(void**)(&resourceCreator), width, height, dpi, &renderTarget));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeightAndDpi(*(void**)(&resourceCreator), width, height, dpi, &renderTarget));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget{ renderTarget, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasRenderTargetFactory<D>::CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float width, float height, float dpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* renderTarget{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(*(void**)(&resourceCreator), width, height, dpi, static_cast<int32_t>(format), static_cast<int32_t>(alpha), &renderTarget));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(*(void**)(&resourceCreator), width, height, dpi, static_cast<int32_t>(format), static_cast<int32_t>(alpha), &renderTarget));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget{ renderTarget, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasRenderTargetStatics<D>::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11Surface(*(void**)(&resourceCreator), *(void**)(&surface), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11Surface(*(void**)(&resourceCreator), *(void**)(&surface), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasRenderTargetStatics<D>::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface, float dpi) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11SurfaceWithDpi(*(void**)(&resourceCreator), *(void**)(&surface), dpi, &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11SurfaceWithDpi(*(void**)(&resourceCreator), *(void**)(&surface), dpi, &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasRenderTargetStatics<D>::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* bitmap{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11SurfaceWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&surface), dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>**)this;
            check_hresult(_winrt_abi_type->CreateFromDirect3D11SurfaceWithDpiAndAlpha(*(void**)(&resourceCreator), *(void**)(&surface), dpi, static_cast<int32_t>(alpha), &bitmap));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget{ bitmap, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasResourceCreator<D>::Device() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Device(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator>**)this;
            check_hresult(_winrt_abi_type->get_Device(&value));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasResourceCreatorWithDpi<D>::Dpi() const
    {
        float dpi{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Dpi(&dpi));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>**)this;
            check_hresult(_winrt_abi_type->get_Dpi(&dpi));
        }
        return dpi;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasResourceCreatorWithDpi<D>::ConvertPixelsToDips(int32_t pixels) const
    {
        float dips{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ConvertPixelsToDips(pixels, &dips));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>**)this;
            check_hresult(_winrt_abi_type->ConvertPixelsToDips(pixels, &dips));
        }
        return dips;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasResourceCreatorWithDpi<D>::ConvertDipsToPixels(float dips, winrt::Microsoft::Graphics::Canvas::CanvasDpiRounding const& dpiRounding) const
    {
        int32_t pixels{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ConvertDipsToPixels(dips, static_cast<int32_t>(dpiRounding), &pixels));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>**)this;
            check_hresult(_winrt_abi_type->ConvertDipsToPixels(dips, static_cast<int32_t>(dpiRounding), &pixels));
        }
        return pixels;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Rect const& destRect) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawToRect(*(void**)(&bitmap), impl::bind_in(destRect)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawToRect(*(void**)(&bitmap), impl::bind_in(destRect)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float2 const& offset) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawAtOffset(*(void**)(&bitmap), impl::bind_in(offset)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawAtOffset(*(void**)(&bitmap), impl::bind_in(offset)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float3x2 const& transform) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawWithTransform(*(void**)(&bitmap), impl::bind_in(transform)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawWithTransform(*(void**)(&bitmap), impl::bind_in(transform)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Rect const& destRect, winrt::Windows::Foundation::Numerics::float4 const& tint) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawToRectWithTint(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(tint)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawToRectWithTint(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(tint)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Numerics::float4 const& tint) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawAtOffsetWithTint(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(tint)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawAtOffsetWithTint(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(tint)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float3x2 const& transform, winrt::Windows::Foundation::Numerics::float4 const& tint) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawWithTransformAndTint(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(tint)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawWithTransformAndTint(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(tint)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Rect const& destRect, winrt::Windows::Foundation::Numerics::float4 const& tint, winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const& flip) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawToRectWithTintAndFlip(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(tint), static_cast<uint32_t>(flip)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawToRectWithTintAndFlip(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(tint), static_cast<uint32_t>(flip)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float3x2 const& transform, winrt::Windows::Foundation::Numerics::float4 const& tint, winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const& flip) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawWithTransformAndTintAndFlip(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(tint), static_cast<uint32_t>(flip)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawWithTransformAndTintAndFlip(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(tint), static_cast<uint32_t>(flip)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::Draw(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Numerics::float4 const& tint, winrt::Windows::Foundation::Numerics::float2 const& origin, float rotation, winrt::Windows::Foundation::Numerics::float2 const& scale, winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const& flip) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawAtOffsetWithTintAndTransform(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(tint), impl::bind_in(origin), rotation, impl::bind_in(scale), static_cast<uint32_t>(flip)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawAtOffsetWithTintAndTransform(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(tint), impl::bind_in(origin), rotation, impl::bind_in(scale), static_cast<uint32_t>(flip)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Rect const& destRect, winrt::Windows::Foundation::Rect const& sourceRect) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetToRect(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(sourceRect)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetToRect(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(sourceRect)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Rect const& sourceRect) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetAtOffset(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(sourceRect)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetAtOffset(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(sourceRect)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float3x2 const& transform, winrt::Windows::Foundation::Rect const& sourceRect) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetWithTransform(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(sourceRect)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetWithTransform(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(sourceRect)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Rect const& destRect, winrt::Windows::Foundation::Rect const& sourceRect, winrt::Windows::Foundation::Numerics::float4 const& tint) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetToRectWithTint(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(sourceRect), impl::bind_in(tint)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetToRectWithTint(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(sourceRect), impl::bind_in(tint)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Rect const& sourceRect, winrt::Windows::Foundation::Numerics::float4 const& tint) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetAtOffsetWithTint(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(sourceRect), impl::bind_in(tint)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetAtOffsetWithTint(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(sourceRect), impl::bind_in(tint)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float3x2 const& transform, winrt::Windows::Foundation::Rect const& sourceRect, winrt::Windows::Foundation::Numerics::float4 const& tint) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetWithTransformAndTint(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(sourceRect), impl::bind_in(tint)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetWithTransformAndTint(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(sourceRect), impl::bind_in(tint)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Rect const& destRect, winrt::Windows::Foundation::Rect const& sourceRect, winrt::Windows::Foundation::Numerics::float4 const& tint, winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const& flip) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetToRectWithTintAndFlip(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(sourceRect), impl::bind_in(tint), static_cast<uint32_t>(flip)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetToRectWithTintAndFlip(*(void**)(&bitmap), impl::bind_in(destRect), impl::bind_in(sourceRect), impl::bind_in(tint), static_cast<uint32_t>(flip)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float3x2 const& transform, winrt::Windows::Foundation::Rect const& sourceRect, winrt::Windows::Foundation::Numerics::float4 const& tint, winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const& flip) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetWithTransformAndTintAndFlip(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(sourceRect), impl::bind_in(tint), static_cast<uint32_t>(flip)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetWithTransformAndTintAndFlip(*(void**)(&bitmap), impl::bind_in(transform), impl::bind_in(sourceRect), impl::bind_in(tint), static_cast<uint32_t>(flip)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatch<D>::DrawFromSpriteSheet(winrt::Microsoft::Graphics::Canvas::CanvasBitmap const& bitmap, winrt::Windows::Foundation::Numerics::float2 const& offset, winrt::Windows::Foundation::Rect const& sourceRect, winrt::Windows::Foundation::Numerics::float4 const& tint, winrt::Windows::Foundation::Numerics::float2 const& origin, float rotation, winrt::Windows::Foundation::Numerics::float2 const& scale, winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const& flip) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetAtOffsetWithTintAndTransform(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(sourceRect), impl::bind_in(tint), impl::bind_in(origin), rotation, impl::bind_in(scale), static_cast<uint32_t>(flip)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>**)this;
            check_hresult(_winrt_abi_type->DrawFromSpriteSheetAtOffsetWithTintAndTransform(*(void**)(&bitmap), impl::bind_in(offset), impl::bind_in(sourceRect), impl::bind_in(tint), impl::bind_in(origin), rotation, impl::bind_in(scale), static_cast<uint32_t>(flip)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSpriteBatchStatics<D>::IsSupported(winrt::Microsoft::Graphics::Canvas::CanvasDevice const& device) const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatchStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatchStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatchStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->IsSupported(*(void**)(&device), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatchStatics>**)this;
            check_hresult(_winrt_abi_type->IsSupported(*(void**)(&device), &value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::Present() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->Present());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->Present());
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::Present(int32_t syncInterval) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->PresentWithSyncInterval(syncInterval));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->PresentWithSyncInterval(syncInterval));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::ResizeBuffers(winrt::Windows::Foundation::Size const& newSize) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ResizeBuffersWithSize(impl::bind_in(newSize)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->ResizeBuffersWithSize(impl::bind_in(newSize)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::ResizeBuffers(float newWidth, float newHeight) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ResizeBuffersWithWidthAndHeight(newWidth, newHeight));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->ResizeBuffersWithWidthAndHeight(newWidth, newHeight));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::ResizeBuffers(float newWidth, float newHeight, float newDpi) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ResizeBuffersWithWidthAndHeightAndDpi(newWidth, newHeight, newDpi));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->ResizeBuffersWithWidthAndHeightAndDpi(newWidth, newHeight, newDpi));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::ResizeBuffers(float newWidth, float newHeight, float newDpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& newFormat, int32_t bufferCount) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->ResizeBuffersWithAllOptions(newWidth, newHeight, newDpi, static_cast<int32_t>(newFormat), bufferCount));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->ResizeBuffersWithAllOptions(newWidth, newHeight, newDpi, static_cast<int32_t>(newFormat), bufferCount));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::Size() const
    {
        winrt::Windows::Foundation::Size size{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Size(put_abi(size)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->get_Size(put_abi(size)));
        }
        return size;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::SizeInPixels() const
    {
        winrt::Windows::Graphics::Imaging::BitmapSize size{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SizeInPixels(put_abi(size)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->get_SizeInPixels(put_abi(size)));
        }
        return size;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::Format() const
    {
        winrt::Windows::Graphics::DirectX::DirectXPixelFormat value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Format(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->get_Format(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::BufferCount() const
    {
        int32_t value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_BufferCount(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->get_BufferCount(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::AlphaMode() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_AlphaMode(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->get_AlphaMode(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::Rotation() const
    {
        winrt::Microsoft::Graphics::Canvas::CanvasSwapChainRotation value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Rotation(reinterpret_cast<int32_t*>(&value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->get_Rotation(reinterpret_cast<int32_t*>(&value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::Rotation(winrt::Microsoft::Graphics::Canvas::CanvasSwapChainRotation const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_Rotation(static_cast<int32_t>(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->put_Rotation(static_cast<int32_t>(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::SourceSize() const
    {
        winrt::Windows::Foundation::Size value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SourceSize(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->get_SourceSize(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::SourceSize(winrt::Windows::Foundation::Size const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_SourceSize(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->put_SourceSize(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::TransformMatrix() const
    {
        winrt::Windows::Foundation::Numerics::float3x2 value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_TransformMatrix(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->get_TransformMatrix(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::TransformMatrix(winrt::Windows::Foundation::Numerics::float3x2 const& value) const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->put_TransformMatrix(impl::bind_in(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->put_TransformMatrix(impl::bind_in(value)));
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::CreateDrawingSession(winrt::Windows::UI::Color const& clearColor) const
    {
        void* drawingSession{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateDrawingSession(impl::bind_in(clearColor), &drawingSession));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->CreateDrawingSession(impl::bind_in(clearColor), &drawingSession));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession{ drawingSession, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChain<D>::WaitForVerticalBlank() const
    {
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->WaitForVerticalBlank());
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>**)this;
            check_hresult(_winrt_abi_type->WaitForVerticalBlank());
        }
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChainFactory<D>::CreateWithSize(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const& resourceCreator, winrt::Windows::Foundation::Size const& size) const
    {
        void* swapChain{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithSize(*(void**)(&resourceCreator), impl::bind_in(size), &swapChain));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithSize(*(void**)(&resourceCreator), impl::bind_in(size), &swapChain));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSwapChain{ swapChain, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChainFactory<D>::CreateWithWidthAndHeight(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const& resourceCreator, float width, float height) const
    {
        void* swapChain{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeight(*(void**)(&resourceCreator), width, height, &swapChain));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeight(*(void**)(&resourceCreator), width, height, &swapChain));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSwapChain{ swapChain, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChainFactory<D>::CreateWithWidthAndHeightAndDpi(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float width, float height, float dpi) const
    {
        void* swapChain{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeightAndDpi(*(void**)(&resourceCreator), width, height, dpi, &swapChain));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithWidthAndHeightAndDpi(*(void**)(&resourceCreator), width, height, dpi, &swapChain));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSwapChain{ swapChain, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChainFactory<D>::CreateWithAllOptions(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float width, float height, float dpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, int32_t bufferCount, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode) const
    {
        void* swapChain{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateWithAllOptions(*(void**)(&resourceCreator), width, height, dpi, static_cast<int32_t>(format), bufferCount, static_cast<int32_t>(alphaMode), &swapChain));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>**)this;
            check_hresult(_winrt_abi_type->CreateWithAllOptions(*(void**)(&resourceCreator), width, height, dpi, static_cast<int32_t>(format), bufferCount, static_cast<int32_t>(alphaMode), &swapChain));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSwapChain{ swapChain, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChainStatics<D>::CreateForCoreWindow(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Core::CoreWindow const& coreWindow, float dpi) const
    {
        void* swapChain{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForCoreWindowWithDpi(*(void**)(&resourceCreator), *(void**)(&coreWindow), dpi, &swapChain));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForCoreWindowWithDpi(*(void**)(&resourceCreator), *(void**)(&coreWindow), dpi, &swapChain));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSwapChain{ swapChain, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChainStatics<D>::CreateForCoreWindow(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Core::CoreWindow const& coreWindow, float width, float height, float dpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, int32_t bufferCount) const
    {
        void* swapChain{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForCoreWindowWithAllOptions(*(void**)(&resourceCreator), *(void**)(&coreWindow), width, height, dpi, static_cast<int32_t>(format), bufferCount, &swapChain));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForCoreWindowWithAllOptions(*(void**)(&resourceCreator), *(void**)(&coreWindow), width, height, dpi, static_cast<int32_t>(format), bufferCount, &swapChain));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSwapChain{ swapChain, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChainStatics<D>::CreateForWindowId(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Microsoft::UI::WindowId const& windowId, float width, float height, float dpi) const
    {
        void* swapChain{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForWindowIdWithDpi(*(void**)(&resourceCreator), impl::bind_in(windowId), width, height, dpi, &swapChain));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForWindowIdWithDpi(*(void**)(&resourceCreator), impl::bind_in(windowId), width, height, dpi, &swapChain));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSwapChain{ swapChain, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasSwapChainStatics<D>::CreateForWindowId(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Microsoft::UI::WindowId const& windowId, float width, float height, float dpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, int32_t bufferCount) const
    {
        void* swapChain{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->CreateForWindowIdWithAllOptions(*(void**)(&resourceCreator), impl::bind_in(windowId), width, height, dpi, static_cast<int32_t>(format), bufferCount, &swapChain));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>**)this;
            check_hresult(_winrt_abi_type->CreateForWindowIdWithAllOptions(*(void**)(&resourceCreator), impl::bind_in(windowId), width, height, dpi, static_cast<int32_t>(format), bufferCount, &swapChain));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasSwapChain{ swapChain, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmap<D>::Device() const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Device(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)this;
            check_hresult(_winrt_abi_type->get_Device(&value));
        }
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmap<D>::IsCachedOnDemand() const
    {
        bool value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_IsCachedOnDemand(&value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)this;
            check_hresult(_winrt_abi_type->get_IsCachedOnDemand(&value));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmap<D>::SizeInPixels() const
    {
        winrt::Windows::Graphics::Imaging::BitmapSize value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_SizeInPixels(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)this;
            check_hresult(_winrt_abi_type->get_SizeInPixels(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmap<D>::Size() const
    {
        winrt::Windows::Foundation::Size value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Size(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)this;
            check_hresult(_winrt_abi_type->get_Size(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmap<D>::Bounds() const
    {
        winrt::Windows::Foundation::Rect value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->get_Bounds(put_abi(value)));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>**)this;
            check_hresult(_winrt_abi_type->get_Bounds(put_abi(value)));
        }
        return value;
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromFileName(*(void**)(&resourceCreator), *(void**)(&fileName), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromFileName(*(void**)(&resourceCreator), *(void**)(&fileName), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromFileNameWithOptions(*(void**)(&resourceCreator), *(void**)(&fileName), static_cast<int32_t>(options), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromFileNameWithOptions(*(void**)(&resourceCreator), *(void**)(&fileName), static_cast<int32_t>(options), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromFileNameWithOptionsAndAlpha(*(void**)(&resourceCreator), *(void**)(&fileName), static_cast<int32_t>(options), static_cast<int32_t>(alpha), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromFileNameWithOptionsAndAlpha(*(void**)(&resourceCreator), *(void**)(&fileName), static_cast<int32_t>(options), static_cast<int32_t>(alpha), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromUri(*(void**)(&resourceCreator), *(void**)(&uri), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromUri(*(void**)(&resourceCreator), *(void**)(&uri), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromUriWithOptions(*(void**)(&resourceCreator), *(void**)(&uri), static_cast<int32_t>(options), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromUriWithOptions(*(void**)(&resourceCreator), *(void**)(&uri), static_cast<int32_t>(options), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromUriWithOptionsAndAlpha(*(void**)(&resourceCreator), *(void**)(&uri), static_cast<int32_t>(options), static_cast<int32_t>(alpha), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromUriWithOptionsAndAlpha(*(void**)(&resourceCreator), *(void**)(&uri), static_cast<int32_t>(options), static_cast<int32_t>(alpha), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromStream(*(void**)(&resourceCreator), *(void**)(&stream), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromStream(*(void**)(&resourceCreator), *(void**)(&stream), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromStreamWithOptions(*(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(options), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromStreamWithOptions(*(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(options), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_Microsoft_Graphics_Canvas_ICanvasVirtualBitmapStatics<D>::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) const
    {
        void* value{};
        if constexpr (!std::is_same_v<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>)
        {
            winrt::hresult _winrt_cast_result_code;
            auto const _winrt_casted_result = impl::try_as_with_reason<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics, D const*>(static_cast<D const*>(this), _winrt_cast_result_code);
            check_hresult(_winrt_cast_result_code);
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)&_winrt_casted_result;
            check_hresult(_winrt_abi_type->LoadAsyncFromStreamWithOptionsAndAlpha(*(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(options), static_cast<int32_t>(alpha), &value));
        }
        else
        {
            auto const _winrt_abi_type = *(abi_t<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>**)this;
            check_hresult(_winrt_abi_type->LoadAsyncFromStreamWithOptionsAndAlpha(*(void**)(&resourceCreator), *(void**)(&stream), static_cast<int32_t>(options), static_cast<int32_t>(alpha), &value));
        }
        return winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>{ value, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasActiveLayer> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasActiveLayer>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmap>
    {
        int32_t __stdcall get_SizeInPixels(struct struct_Windows_Graphics_Imaging_BitmapSize* size) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::Imaging::BitmapSize>(size);
            typename D::abi_guard guard(this->shim());
            *size = detach_from<winrt::Windows::Graphics::Imaging::BitmapSize>(this->shim().SizeInPixels());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Size(winrt::Windows::Foundation::Size* size) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(size);
            typename D::abi_guard guard(this->shim());
            *size = detach_from<winrt::Windows::Foundation::Size>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Bounds(winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().Bounds());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Format(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(this->shim().Format());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AlphaMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode>(this->shim().AlphaMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveToFileAsync(void* fileName, void** asyncAction) noexcept final try
        {
            clear_abi(asyncAction);
            typename D::abi_guard guard(this->shim());
            *asyncAction = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync(*reinterpret_cast<hstring const*>(&fileName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveToFileWithBitmapFileFormatAsync(void* fileName, int32_t fileFormat, void** asyncAction) noexcept final try
        {
            clear_abi(asyncAction);
            typename D::abi_guard guard(this->shim());
            *asyncAction = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync(*reinterpret_cast<hstring const*>(&fileName), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const*>(&fileFormat)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveToFileWithBitmapFileFormatAndQualityAsync(void* fileName, int32_t fileFormat, float quality, void** asyncAction) noexcept final try
        {
            clear_abi(asyncAction);
            typename D::abi_guard guard(this->shim());
            *asyncAction = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync(*reinterpret_cast<hstring const*>(&fileName), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const*>(&fileFormat), quality));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveToStreamAsync(void* stream, int32_t fileFormat, void** asyncAction) noexcept final try
        {
            clear_abi(asyncAction);
            typename D::abi_guard guard(this->shim());
            *asyncAction = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync(*reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const*>(&fileFormat)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveToStreamWithQualityAsync(void* stream, int32_t fileFormat, float quality, void** asyncAction) noexcept final try
        {
            clear_abi(asyncAction);
            typename D::abi_guard guard(this->shim());
            *asyncAction = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync(*reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const*>(&fileFormat), quality));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPixelBytes(uint32_t* __valueElementsSize, uint8_t** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().GetPixelBytes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPixelBytesWithSubrectangle(int32_t left, int32_t top, int32_t width, int32_t height, uint32_t* __valueElementsSize, uint8_t** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().GetPixelBytes(left, top, width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPixelBytesWithBuffer(void* buffer) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GetPixelBytes(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPixelBytesWithBufferAndSubrectangle(void* buffer, int32_t left, int32_t top, int32_t width, int32_t height) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GetPixelBytes(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), left, top, width, height);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPixelColors(uint32_t* __valueElementsSize, struct struct_Windows_UI_Color** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().GetPixelColors());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetPixelColorsWithSubrectangle(int32_t left, int32_t top, int32_t width, int32_t height, uint32_t* __valueElementsSize, struct struct_Windows_UI_Color** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().GetPixelColors(left, top, width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetPixelBytes(uint32_t __valueElementsSize, uint8_t* valueElements) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPixelBytes(array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(valueElements), reinterpret_cast<uint8_t const *>(valueElements) + __valueElementsSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetPixelBytesWithSubrectangle(uint32_t __valueElementsSize, uint8_t* valueElements, int32_t left, int32_t top, int32_t width, int32_t height) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPixelBytes(array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(valueElements), reinterpret_cast<uint8_t const *>(valueElements) + __valueElementsSize), left, top, width, height);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetPixelBytesWithBuffer(void* buffer) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPixelBytes(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetPixelBytesWithBufferAndSubrectangle(void* buffer, int32_t left, int32_t top, int32_t width, int32_t height) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPixelBytes(*reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), left, top, width, height);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetPixelColors(uint32_t __valueElementsSize, struct struct_Windows_UI_Color* valueElements) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPixelColors(array_view<winrt::Windows::UI::Color const>(reinterpret_cast<winrt::Windows::UI::Color const *>(valueElements), reinterpret_cast<winrt::Windows::UI::Color const *>(valueElements) + __valueElementsSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetPixelColorsWithSubrectangle(uint32_t __valueElementsSize, struct struct_Windows_UI_Color* valueElements, int32_t left, int32_t top, int32_t width, int32_t height) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetPixelColors(array_view<winrt::Windows::UI::Color const>(reinterpret_cast<winrt::Windows::UI::Color const *>(valueElements), reinterpret_cast<winrt::Windows::UI::Color const *>(valueElements) + __valueElementsSize), left, top, width, height);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CopyPixelsFromBitmap(void* otherBitmap) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CopyPixelsFromBitmap(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&otherBitmap));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CopyPixelsFromBitmapWithDestPoint(void* otherBitmap, int32_t destX, int32_t destY) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CopyPixelsFromBitmap(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&otherBitmap), destX, destY);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CopyPixelsFromBitmapWithDestPointAndSourceRect(void* otherBitmap, int32_t destX, int32_t destY, int32_t sourceRectLeft, int32_t sourceRectTop, int32_t sourceRectWidth, int32_t sourceRectHeight) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CopyPixelsFromBitmap(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&otherBitmap), destX, destY, sourceRectLeft, sourceRectTop, sourceRectWidth, sourceRectHeight);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapFactory>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics>
    {
        int32_t __stdcall CreateFromDirect3D11Surface(void* resourceCreator, void* surface, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromDirect3D11Surface(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const*>(&surface)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromDirect3D11SurfaceWithDpi(void* resourceCreator, void* surface, float dpi, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromDirect3D11Surface(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const*>(&surface), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromDirect3D11SurfaceWithDpiAndAlpha(void* resourceCreator, void* surface, float dpi, int32_t alpha, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromDirect3D11Surface(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const*>(&surface), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromBytes(void* resourceCreator, uint32_t __bytesSize, uint8_t* bytes, int32_t widthInPixels, int32_t heightInPixels, int32_t format, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromBytes(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(bytes), reinterpret_cast<uint8_t const *>(bytes) + __bytesSize), widthInPixels, heightInPixels, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromBytesWithDpi(void* resourceCreator, uint32_t __bytesSize, uint8_t* bytes, int32_t widthInPixels, int32_t heightInPixels, int32_t format, float dpi, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromBytes(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(bytes), reinterpret_cast<uint8_t const *>(bytes) + __bytesSize), widthInPixels, heightInPixels, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromBytesWithDpiAndAlpha(void* resourceCreator, uint32_t __bytesSize, uint8_t* bytes, int32_t widthInPixels, int32_t heightInPixels, int32_t format, float dpi, int32_t alpha, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromBytes(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(bytes), reinterpret_cast<uint8_t const *>(bytes) + __bytesSize), widthInPixels, heightInPixels, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromBytesWithBuffer(void* resourceCreator, void* buffer, int32_t widthInPixels, int32_t heightInPixels, int32_t format, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromBytes(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), widthInPixels, heightInPixels, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromBytesWithBufferAndDpi(void* resourceCreator, void* buffer, int32_t widthInPixels, int32_t heightInPixels, int32_t format, float dpi, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromBytes(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), widthInPixels, heightInPixels, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromBytesWithBufferAndDpiAndAlpha(void* resourceCreator, void* buffer, int32_t widthInPixels, int32_t heightInPixels, int32_t format, float dpi, int32_t alpha, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromBytes(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IBuffer const*>(&buffer), widthInPixels, heightInPixels, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromColors(void* resourceCreator, uint32_t __colorsSize, struct struct_Windows_UI_Color* colors, int32_t widthInPixels, int32_t heightInPixels, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromColors(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Windows::UI::Color const>(reinterpret_cast<winrt::Windows::UI::Color const *>(colors), reinterpret_cast<winrt::Windows::UI::Color const *>(colors) + __colorsSize), widthInPixels, heightInPixels));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromColorsWithDpi(void* resourceCreator, uint32_t __colorsSize, struct struct_Windows_UI_Color* colors, int32_t widthInPixels, int32_t heightInPixels, float dpi, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromColors(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Windows::UI::Color const>(reinterpret_cast<winrt::Windows::UI::Color const *>(colors), reinterpret_cast<winrt::Windows::UI::Color const *>(colors) + __colorsSize), widthInPixels, heightInPixels, dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromColorsWithDpiAndAlpha(void* resourceCreator, uint32_t __colorsSize, struct struct_Windows_UI_Color* colors, int32_t widthInPixels, int32_t heightInPixels, float dpi, int32_t alpha, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromColors(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), array_view<winrt::Windows::UI::Color const>(reinterpret_cast<winrt::Windows::UI::Color const *>(colors), reinterpret_cast<winrt::Windows::UI::Color const *>(colors) + __colorsSize), widthInPixels, heightInPixels, dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromSoftwareBitmap(void* resourceCreator, void* sourceBitmap, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>(this->shim().CreateFromSoftwareBitmap(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Graphics::Imaging::SoftwareBitmap const*>(&sourceBitmap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromHstring(void* resourceCreator, void* fileName, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<hstring const*>(&fileName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromHstringWithDpi(void* resourceCreator, void* fileName, float dpi, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<hstring const*>(&fileName), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromHstringWithDpiAndAlpha(void* resourceCreator, void* fileName, float dpi, int32_t alpha, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<hstring const*>(&fileName), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromUri(void* resourceCreator, void* uri, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&uri)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromUriWithDpi(void* resourceCreator, void* uri, float dpi, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&uri), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromUriWithDpiAndAlpha(void* resourceCreator, void* uri, float dpi, int32_t alpha, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&uri), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromStream(void* resourceCreator, void* stream, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromStreamWithDpi(void* resourceCreator, void* stream, float dpi, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromStreamWithDpiAndAlpha(void* resourceCreator, void* stream, float dpi, int32_t alpha, void** canvasBitmap) noexcept final try
        {
            clear_abi(canvasBitmap);
            typename D::abi_guard guard(this->shim());
            *canvasBitmap = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasCommandList> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasCommandList>
    {
        int32_t __stdcall CreateDrawingSession(void** drawingSession) noexcept final try
        {
            clear_abi(drawingSession);
            typename D::abi_guard guard(this->shim());
            *drawingSession = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession>(this->shim().CreateDrawingSession());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Device(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasCommandListFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasCommandListFactory>
    {
        int32_t __stdcall Create(void* resourceCreator, void** commandList) noexcept final try
        {
            clear_abi(commandList);
            typename D::abi_guard guard(this->shim());
            *commandList = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasCommandList>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasDevice>
    {
        int32_t __stdcall get_ForceSoftwareRenderer(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ForceSoftwareRenderer());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaximumBitmapSizeInPixels(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaximumBitmapSizeInPixels());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsPixelFormatSupported(int32_t pixelFormat, bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsPixelFormatSupported(*reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&pixelFormat)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsBufferPrecisionSupported(int32_t bufferPrecision, bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsBufferPrecisionSupported(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const*>(&bufferPrecision)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaximumCacheSize(uint64_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint64_t>(this->shim().MaximumCacheSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaximumCacheSize(uint64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaximumCacheSize(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LowPriority(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().LowPriority());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LowPriority(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LowPriority(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_DeviceLost(void* value, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().DeviceLost(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Graphics::Canvas::CanvasDevice, winrt::Windows::Foundation::IInspectable> const*>(&value)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_DeviceLost(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DeviceLost(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall IsDeviceLost(int32_t hresult, bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsDeviceLost(hresult));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RaiseDeviceLost() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RaiseDeviceLost();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Lock(void** lock) noexcept final try
        {
            clear_abi(lock);
            typename D::abi_guard guard(this->shim());
            *lock = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasLock>(this->shim().Lock());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsDeviceLost2(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsDeviceLost());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeviceLostReason(int32_t* hresult) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *hresult = detach_from<int32_t>(this->shim().GetDeviceLostReason());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceFactory>
    {
        int32_t __stdcall CreateWithForceSoftwareRendererOption(bool forceSoftwareRenderer, void** canvasDevice) noexcept final try
        {
            clear_abi(canvasDevice);
            typename D::abi_guard guard(this->shim());
            *canvasDevice = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().CreateWithForceSoftwareRendererOption(forceSoftwareRenderer));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics>
    {
        int32_t __stdcall CreateFromDirect3D11Device(void* direct3DDevice, void** canvasDevice) noexcept final try
        {
            clear_abi(canvasDevice);
            typename D::abi_guard guard(this->shim());
            *canvasDevice = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().CreateFromDirect3D11Device(*reinterpret_cast<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice const*>(&direct3DDevice)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSharedDevice(void** canvasDevice) noexcept final try
        {
            clear_abi(canvasDevice);
            typename D::abi_guard guard(this->shim());
            *canvasDevice = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().GetSharedDevice());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSharedDeviceWithForceSoftwareRenderer(bool forceSoftwareRenderer, void** canvasDevice) noexcept final try
        {
            clear_abi(canvasDevice);
            typename D::abi_guard guard(this->shim());
            *canvasDevice = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().GetSharedDevice(forceSoftwareRenderer));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DebugLevel(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DebugLevel(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasDebugLevel const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DebugLevel(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDebugLevel>(this->shim().DebugLevel());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession>
    {
        int32_t __stdcall Clear(struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Clear(*reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ClearHdr(winrt::Windows::Foundation::Numerics::float4 color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Clear(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Flush() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Flush();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtOrigin(void* image) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtOffset(void* image, winrt::Windows::Foundation::Numerics::float2 offset) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtCoords(void* image, float x, float y) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), x, y);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageToRect(void* bitmap, winrt::Windows::Foundation::Rect destinationRectangle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destinationRectangle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtOffsetWithSourceRect(void* image, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Rect sourceRectangle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtCoordsWithSourceRect(void* image, float x, float y, winrt::Windows::Foundation::Rect sourceRectangle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), x, y, *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageToRectWithSourceRect(void* image, winrt::Windows::Foundation::Rect destinationRectangle, winrt::Windows::Foundation::Rect sourceRectangle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destinationRectangle), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtOffsetWithSourceRectAndOpacity(void* image, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Rect sourceRectangle, float opacity) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtCoordsWithSourceRectAndOpacity(void* image, float x, float y, winrt::Windows::Foundation::Rect sourceRectangle, float opacity) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), x, y, *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageToRectWithSourceRectAndOpacity(void* image, winrt::Windows::Foundation::Rect destinationRectangle, winrt::Windows::Foundation::Rect sourceRectangle, float opacity) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destinationRectangle), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolation(void* image, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolation(void* image, float x, float y, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), x, y, *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageToRectWithSourceRectAndOpacityAndInterpolation(void* image, winrt::Windows::Foundation::Rect destinationRectangle, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destinationRectangle), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndComposite(void* image, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation, int32_t composite) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasComposite const*>(&composite));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndComposite(void* image, float x, float y, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation, int32_t composite) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), x, y, *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasComposite const*>(&composite));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndComposite(void* image, winrt::Windows::Foundation::Rect destinationRectangle, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation, int32_t composite) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destinationRectangle), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasComposite const*>(&composite));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndPerspective(void* bitmap, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation, winrt::Windows::Foundation::Numerics::float4x4 perspective) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4x4 const*>(&perspective));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndPerspective(void* bitmap, float x, float y, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation, winrt::Windows::Foundation::Numerics::float4x4 perspective) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), x, y, *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4x4 const*>(&perspective));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndPerspective(void* bitmap, winrt::Windows::Foundation::Rect destinationRectangle, winrt::Windows::Foundation::Rect sourceRectangle, float opacity, int32_t interpolation, winrt::Windows::Foundation::Numerics::float4x4 perspective) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawImage(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destinationRectangle), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4x4 const*>(&perspective));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineWithBrush(winrt::Windows::Foundation::Numerics::float2 point0, winrt::Windows::Foundation::Numerics::float2 point1, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point0), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point1), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineAtCoordsWithBrush(float x0, float y0, float x1, float y1, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(x0, y0, x1, y1, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineWithColor(winrt::Windows::Foundation::Numerics::float2 point0, winrt::Windows::Foundation::Numerics::float2 point1, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point0), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point1), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineAtCoordsWithColor(float x0, float y0, float x1, float y1, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(x0, y0, x1, y1, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineWithBrushAndStrokeWidth(winrt::Windows::Foundation::Numerics::float2 point0, winrt::Windows::Foundation::Numerics::float2 point1, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point0), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point1), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineAtCoordsWithBrushAndStrokeWidth(float x0, float y0, float x1, float y1, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(x0, y0, x1, y1, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineWithColorAndStrokeWidth(winrt::Windows::Foundation::Numerics::float2 point0, winrt::Windows::Foundation::Numerics::float2 point1, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point0), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point1), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineAtCoordsWithColorAndStrokeWidth(float x0, float y0, float x1, float y1, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(x0, y0, x1, y1, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineWithBrushAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Numerics::float2 point0, winrt::Windows::Foundation::Numerics::float2 point1, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point0), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point1), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(float x0, float y0, float x1, float y1, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(x0, y0, x1, y1, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineWithColorAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Numerics::float2 point0, winrt::Windows::Foundation::Numerics::float2 point1, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point0), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point1), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawLineAtCoordsWithColorAndStrokeWidthAndStrokeStyle(float x0, float y0, float x1, float y1, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawLine(x0, y0, x1, y1, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleWithBrush(winrt::Windows::Foundation::Rect rect, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleAtCoordsWithBrush(float x, float y, float w, float h, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(x, y, w, h, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleWithColor(winrt::Windows::Foundation::Rect rect, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleAtCoordsWithColor(float x, float y, float w, float h, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(x, y, w, h, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleWithBrushAndStrokeWidth(winrt::Windows::Foundation::Rect rect, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleAtCoordsWithBrushAndStrokeWidth(float x, float y, float w, float h, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(x, y, w, h, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleWithColorAndStrokeWidth(winrt::Windows::Foundation::Rect rect, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleAtCoordsWithColorAndStrokeWidth(float x, float y, float w, float h, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(x, y, w, h, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleWithBrushAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Rect rect, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(float x, float y, float w, float h, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(x, y, w, h, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleWithColorAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Rect rect, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(float x, float y, float w, float h, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRectangle(x, y, w, h, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRectangleWithBrush(winrt::Windows::Foundation::Rect rect, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRectangleAtCoordsWithBrush(float x, float y, float w, float h, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRectangle(x, y, w, h, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRectangleWithColor(winrt::Windows::Foundation::Rect rect, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRectangleAtCoordsWithColor(float x, float y, float w, float h, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRectangle(x, y, w, h, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRectangleWithBrushAndOpacityBrush(winrt::Windows::Foundation::Rect rect, void* brush, void* opacityBrush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRectangleAtCoordsWithBrushAndOpacityBrush(float x, float y, float w, float h, void* brush, void* opacityBrush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRectangle(x, y, w, h, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleWithBrush(winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleAtCoordsWithBrush(float x, float y, float w, float h, float radiusX, float radiusY, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(x, y, w, h, radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleWithColor(winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleAtCoordsWithColor(float x, float y, float w, float h, float radiusX, float radiusY, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(x, y, w, h, radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleWithBrushAndStrokeWidth(winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidth(float x, float y, float w, float h, float radiusX, float radiusY, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(x, y, w, h, radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleWithColorAndStrokeWidth(winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleAtCoordsWithColorAndStrokeWidth(float x, float y, float w, float h, float radiusX, float radiusY, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(x, y, w, h, radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleWithBrushAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(float x, float y, float w, float h, float radiusX, float radiusY, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(x, y, w, h, radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleWithColorAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawRoundedRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(float x, float y, float w, float h, float radiusX, float radiusY, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawRoundedRectangle(x, y, w, h, radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRoundedRectangleWithBrush(winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRoundedRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRoundedRectangleAtCoordsWithBrush(float x, float y, float w, float h, float radiusX, float radiusY, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRoundedRectangle(x, y, w, h, radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRoundedRectangleWithColor(winrt::Windows::Foundation::Rect rect, float radiusX, float radiusY, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRoundedRectangle(*reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rect), radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillRoundedRectangleAtCoordsWithColor(float x, float y, float w, float h, float radiusX, float radiusY, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillRoundedRectangle(x, y, w, h, radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseWithBrush(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseAtCoordsWithBrush(float x, float y, float radiusX, float radiusY, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(x, y, radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseWithColor(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseAtCoordsWithColor(float x, float y, float radiusX, float radiusY, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(x, y, radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseWithBrushAndStrokeWidth(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseAtCoordsWithBrushAndStrokeWidth(float x, float y, float radiusX, float radiusY, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(x, y, radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseWithColorAndStrokeWidth(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseAtCoordsWithColorAndStrokeWidth(float x, float y, float radiusX, float radiusY, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(x, y, radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseWithBrushAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(float x, float y, float radiusX, float radiusY, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(x, y, radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseWithColorAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawEllipseAtCoordsWithColorAndStrokeWidthAndStrokeStyle(float x, float y, float radiusX, float radiusY, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawEllipse(x, y, radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillEllipseWithBrush(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillEllipse(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillEllipseAtCoordsWithBrush(float x, float y, float radiusX, float radiusY, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillEllipse(x, y, radiusX, radiusY, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillEllipseWithColor(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radiusX, float radiusY, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillEllipse(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillEllipseAtCoordsWithColor(float x, float y, float radiusX, float radiusY, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillEllipse(x, y, radiusX, radiusY, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleWithBrush(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleAtCoordsWithBrush(float x, float y, float radius, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(x, y, radius, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleWithColor(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleAtCoordsWithColor(float x, float y, float radius, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(x, y, radius, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleWithBrushAndStrokeWidth(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleAtCoordsWithBrushAndStrokeWidth(float x, float y, float radius, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(x, y, radius, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleWithColorAndStrokeWidth(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleAtCoordsWithColorAndStrokeWidth(float x, float y, float radius, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(x, y, radius, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleWithBrushAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(float x, float y, float radius, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(x, y, radius, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleWithColorAndStrokeWidthAndStrokeStyle(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCircleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(float x, float y, float radius, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCircle(x, y, radius, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillCircleWithBrush(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillCircle(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillCircleAtCoordsWithBrush(float x, float y, float radius, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillCircle(x, y, radius, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillCircleWithColor(winrt::Windows::Foundation::Numerics::float2 centerPoint, float radius, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillCircle(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&centerPoint), radius, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillCircleAtCoordsWithColor(float x, float y, float radius, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillCircle(x, y, radius, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtPointWithColor(void* text, winrt::Windows::Foundation::Numerics::float2 point, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtPointCoordsWithColor(void* text, float x, float y, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), x, y, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtPointWithBrushAndFormat(void* text, winrt::Windows::Foundation::Numerics::float2 point, void* brush, void* format) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const*>(&format));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtRectWithBrushAndFormat(void* text, winrt::Windows::Foundation::Rect rectangle, void* brush, void* format) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rectangle), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const*>(&format));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtPointCoordsWithBrushAndFormat(void* text, float x, float y, void* brush, void* format) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), x, y, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const*>(&format));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtRectCoordsWithBrushAndFormat(void* text, float x, float y, float w, float h, void* brush, void* format) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), x, y, w, h, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const*>(&format));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtPointWithColorAndFormat(void* text, winrt::Windows::Foundation::Numerics::float2 point, struct struct_Windows_UI_Color color, void* format) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const*>(&format));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtRectWithColorAndFormat(void* text, winrt::Windows::Foundation::Rect rectangle, struct struct_Windows_UI_Color color, void* format) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&rectangle), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const*>(&format));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtPointCoordsWithColorAndFormat(void* text, float x, float y, struct struct_Windows_UI_Color color, void* format) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), x, y, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const*>(&format));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextAtRectCoordsWithColorAndFormat(void* text, float x, float y, float w, float h, struct struct_Windows_UI_Color color, void* format) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawText(*reinterpret_cast<hstring const*>(&text), x, y, w, h, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextFormat const*>(&format));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryWithBrush(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryWithColor(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtCoordsWithBrush(void* geometry, float x, float y, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtCoordsWithColor(void* geometry, float x, float y, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtOriginWithBrush(void* geometry, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtOriginWithColor(void* geometry, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryWithBrushAndStrokeWidth(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryWithColorAndStrokeWidth(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtCoordsWithBrushAndStrokeWidth(void* geometry, float x, float y, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtCoordsWithColorAndStrokeWidth(void* geometry, float x, float y, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtOriginWithBrushAndStrokeWidth(void* geometry, void* brush, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtOriginWithColorAndStrokeWidth(void* geometry, struct struct_Windows_UI_Color color, float strokeWidth) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryWithBrushAndStrokeWidthAndStrokeStyle(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryWithColorAndStrokeWidthAndStrokeStyle(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(void* geometry, float x, float y, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtCoordsWithColorAndStrokeWidthAndStrokeStyle(void* geometry, float x, float y, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtOriginWithBrushAndStrokeWidthAndStrokeStyle(void* geometry, void* brush, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGeometryAtOriginWithColorAndStrokeWidthAndStrokeStyle(void* geometry, struct struct_Windows_UI_Color color, float strokeWidth, void* strokeStyle) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color), strokeWidth, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasStrokeStyle const*>(&strokeStyle));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryWithBrush(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryWithBrushAndOpacityBrush(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, void* brush, void* opacityBrush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryWithColor(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryAtCoordsWithBrush(void* geometry, float x, float y, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryAtCoordsWithBrushAndOpacityBrush(void* geometry, float x, float y, void* brush, void* opacityBrush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryAtCoordsWithColor(void* geometry, float x, float y, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryAtOriginWithBrush(void* geometry, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryAtOriginWithBrushAndOpacityBrush(void* geometry, void* brush, void* opacityBrush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall FillGeometryAtOriginWithColor(void* geometry, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().FillGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCachedGeometryWithBrush(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCachedGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCachedGeometryWithColor(void* geometry, winrt::Windows::Foundation::Numerics::float2 offset, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCachedGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCachedGeometryAtCoordsWithBrush(void* geometry, float x, float y, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCachedGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCachedGeometryAtCoordsWithColor(void* geometry, float x, float y, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCachedGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const*>(&geometry), x, y, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCachedGeometryAtOriginWithBrush(void* geometry, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCachedGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const*>(&geometry), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawCachedGeometryAtOriginWithColor(void* geometry, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawCachedGeometry(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasCachedGeometry const*>(&geometry), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextLayoutWithBrush(void* textLayout, winrt::Windows::Foundation::Numerics::float2 point, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawTextLayout(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const*>(&textLayout), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextLayoutAtCoordsWithBrush(void* textLayout, float x, float y, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawTextLayout(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const*>(&textLayout), x, y, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextLayoutWithColor(void* textLayout, winrt::Windows::Foundation::Numerics::float2 point, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawTextLayout(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const*>(&textLayout), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawTextLayoutAtCoordsWithColor(void* textLayout, float x, float y, struct struct_Windows_UI_Color color) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawTextLayout(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextLayout const*>(&textLayout), x, y, *reinterpret_cast<winrt::Windows::UI::Color const*>(&color));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGradientMeshAtOrigin(void* gradientMesh) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGradientMesh(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh const*>(&gradientMesh));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGradientMesh(void* gradientMesh, winrt::Windows::Foundation::Numerics::float2 point) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGradientMesh(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh const*>(&gradientMesh), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGradientMeshAtCoords(void* gradientMesh, float x, float y) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGradientMesh(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGradientMesh const*>(&gradientMesh), x, y);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawSvgAtOrigin(void* svgDocument, winrt::Windows::Foundation::Size viewportSize) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawSvg(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Svg::CanvasSvgDocument const*>(&svgDocument), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&viewportSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawSvgAtPoint(void* svgDocument, winrt::Windows::Foundation::Size viewportSize, winrt::Windows::Foundation::Numerics::float2 point) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawSvg(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Svg::CanvasSvgDocument const*>(&svgDocument), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&viewportSize), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawSvgAtCoords(void* svgDocument, winrt::Windows::Foundation::Size viewportSize, float x, float y) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawSvg(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Svg::CanvasSvgDocument const*>(&svgDocument), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&viewportSize), x, y);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Antialiasing(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasAntialiasing>(this->shim().Antialiasing());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Antialiasing(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Antialiasing(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAntialiasing const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Blend(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasBlend>(this->shim().Blend());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Blend(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Blend(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBlend const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TextAntialiasing(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextAntialiasing>(this->shim().TextAntialiasing());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TextAntialiasing(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TextAntialiasing(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextAntialiasing const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TextRenderingParameters(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextRenderingParameters>(this->shim().TextRenderingParameters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TextRenderingParameters(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TextRenderingParameters(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextRenderingParameters const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Transform(winrt::Windows::Foundation::Numerics::float3x2* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float3x2>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float3x2>(this->shim().Transform());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Transform(winrt::Windows::Foundation::Numerics::float3x2 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Transform(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Units(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasUnits>(this->shim().Units());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Units(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Units(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasUnits const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EffectBufferPrecision(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IReference<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision>>(this->shim().EffectBufferPrecision());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_EffectBufferPrecision(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EffectBufferPrecision(*reinterpret_cast<winrt::Windows::Foundation::IReference<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision> const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_EffectTileSize(struct struct_Windows_Graphics_Imaging_BitmapSize* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::Imaging::BitmapSize>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Imaging::BitmapSize>(this->shim().EffectTileSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_EffectTileSize(struct struct_Windows_Graphics_Imaging_BitmapSize value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().EffectTileSize(*reinterpret_cast<winrt::Windows::Graphics::Imaging::BitmapSize const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithOpacity(float opacity, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(opacity));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithOpacityBrush(void* opacityBrush, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithOpacityAndClipRectangle(float opacity, winrt::Windows::Foundation::Rect clipRectangle, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(opacity, *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&clipRectangle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithOpacityBrushAndClipRectangle(void* opacityBrush, winrt::Windows::Foundation::Rect clipRectangle, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&clipRectangle)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithOpacityAndClipGeometry(float opacity, void* clipGeometry, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&clipGeometry)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithOpacityBrushAndClipGeometry(void* opacityBrush, void* clipGeometry, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&clipGeometry)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithOpacityAndClipGeometryAndTransform(float opacity, void* clipGeometry, winrt::Windows::Foundation::Numerics::float3x2 geometryTransform, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&clipGeometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&geometryTransform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithOpacityBrushAndClipGeometryAndTransform(void* opacityBrush, void* clipGeometry, winrt::Windows::Foundation::Numerics::float3x2 geometryTransform, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&clipGeometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&geometryTransform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateLayerWithAllOptions(float opacity, void* opacityBrush, winrt::Windows::Foundation::Rect clipRectangle, void* clipGeometry, winrt::Windows::Foundation::Numerics::float3x2 geometryTransform, uint32_t options, void** layer) noexcept final try
        {
            clear_abi(layer);
            typename D::abi_guard guard(this->shim());
            *layer = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer>(this->shim().CreateLayer(opacity, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&opacityBrush), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&clipRectangle), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Geometry::CanvasGeometry const*>(&clipGeometry), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&geometryTransform), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasLayerOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGlyphRun(winrt::Windows::Foundation::Numerics::float2 point, void* fontFace, float fontSize, uint32_t __glyphsSize, struct struct_Microsoft_Graphics_Canvas_Text_CanvasGlyph* glyphs, bool isSideways, uint32_t bidiLevel, void* brush) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGlyphRun(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const*>(&fontFace), fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs) + __glyphsSize), isSideways, bidiLevel, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGlyphRunWithMeasuringMode(winrt::Windows::Foundation::Numerics::float2 point, void* fontFace, float fontSize, uint32_t __glyphsSize, struct struct_Microsoft_Graphics_Canvas_Text_CanvasGlyph* glyphs, bool isSideways, uint32_t bidiLevel, void* brush, int32_t measuringMode) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGlyphRun(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const*>(&fontFace), fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs) + __glyphsSize), isSideways, bidiLevel, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const*>(&measuringMode));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawGlyphRunWithMeasuringModeAndDescription(winrt::Windows::Foundation::Numerics::float2 point, void* fontFace, float fontSize, uint32_t __glyphsSize, struct struct_Microsoft_Graphics_Canvas_Text_CanvasGlyph* glyphs, bool isSideways, uint32_t bidiLevel, void* brush, int32_t measuringMode, void* localeName, void* textString, uint32_t __clusterMapIndicesSize, int32_t* clusterMapIndices, uint32_t textPosition) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawGlyphRun(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&point), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasFontFace const*>(&fontFace), fontSize, array_view<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const>(reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs), reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasGlyph const *>(glyphs) + __glyphsSize), isSideways, bidiLevel, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Brushes::ICanvasBrush const*>(&brush), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Text::CanvasTextMeasuringMode const*>(&measuringMode), *reinterpret_cast<hstring const*>(&localeName), *reinterpret_cast<hstring const*>(&textString), array_view<int32_t const>(reinterpret_cast<int32_t const *>(clusterMapIndices), reinterpret_cast<int32_t const *>(clusterMapIndices) + __clusterMapIndicesSize), textPosition);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateSpriteBatch(void** spriteBatch) noexcept final try
        {
            clear_abi(spriteBatch);
            typename D::abi_guard guard(this->shim());
            *spriteBatch = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch>(this->shim().CreateSpriteBatch());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateSpriteBatchWithSortMode(int32_t sortMode, void** spriteBatch) noexcept final try
        {
            clear_abi(spriteBatch);
            typename D::abi_guard guard(this->shim());
            *spriteBatch = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch>(this->shim().CreateSpriteBatch(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteSortMode const*>(&sortMode)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateSpriteBatchWithSortModeAndInterpolation(int32_t sortMode, int32_t interpolation, void** spriteBatch) noexcept final try
        {
            clear_abi(spriteBatch);
            typename D::abi_guard guard(this->shim());
            *spriteBatch = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch>(this->shim().CreateSpriteBatch(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteSortMode const*>(&sortMode), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateSpriteBatchWithSortModeAndInterpolationAndOptions(int32_t sortMode, int32_t interpolation, uint32_t options, void** spriteBatch) noexcept final try
        {
            clear_abi(spriteBatch);
            typename D::abi_guard guard(this->shim());
            *spriteBatch = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch>(this->shim().CreateSpriteBatch(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteSortMode const*>(&sortMode), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasImageInterpolation const*>(&interpolation), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasImage> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasImage>
    {
        int32_t __stdcall GetBounds(void* resourceCreator, winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().GetBounds(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetBoundsWithTransform(void* resourceCreator, winrt::Windows::Foundation::Numerics::float3x2 transform, winrt::Windows::Foundation::Rect* bounds) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(bounds);
            typename D::abi_guard guard(this->shim());
            *bounds = detach_from<winrt::Windows::Foundation::Rect>(this->shim().GetBounds(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics>
    {
        int32_t __stdcall SaveAsync(void* image, winrt::Windows::Foundation::Rect sourceRectangle, float dpi, void* resourceCreator, void* stream, int32_t fileFormat, void** action) noexcept final try
        {
            clear_abi(action);
            typename D::abi_guard guard(this->shim());
            *action = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const*>(&fileFormat)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveWithQualityAsync(void* image, winrt::Windows::Foundation::Rect sourceRectangle, float dpi, void* resourceCreator, void* stream, int32_t fileFormat, float quality, void** action) noexcept final try
        {
            clear_abi(action);
            typename D::abi_guard guard(this->shim());
            *action = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const*>(&fileFormat), quality));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SaveWithQualityAndBufferPrecisionAsync(void* image, winrt::Windows::Foundation::Rect sourceRectangle, float dpi, void* resourceCreator, void* stream, int32_t fileFormat, float quality, int32_t bufferPrecision, void** action) noexcept final try
        {
            clear_abi(action);
            typename D::abi_guard guard(this->shim());
            *action = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().SaveAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const*>(&fileFormat), quality, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const*>(&bufferPrecision)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ComputeHistogram(void* image, winrt::Windows::Foundation::Rect sourceRectangle, void* resourceCreator, int32_t channelSelect, int32_t numberOfBins, uint32_t* __valueElementsSize, float** valueElements) noexcept final try
        {
            clear_abi(valueElements);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueElementsSize, *valueElements) = detach_abi(this->shim().ComputeHistogram(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasImage const*>(&image), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRectangle), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::Effects::EffectChannelSelect const*>(&channelSelect), numberOfBins));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IsHistogramSupported(void* device, bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IsHistogramSupported(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasDevice const*>(&device)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasLock> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasLock>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTarget> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTarget>
    {
        int32_t __stdcall CreateDrawingSession(void** drawingSession) noexcept final try
        {
            clear_abi(drawingSession);
            typename D::abi_guard guard(this->shim());
            *drawingSession = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession>(this->shim().CreateDrawingSession());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory>
    {
        int32_t __stdcall CreateWithSize(void* resourceCreator, winrt::Windows::Foundation::Size size, void** renderTarget) noexcept final try
        {
            clear_abi(renderTarget);
            typename D::abi_guard guard(this->shim());
            *renderTarget = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget>(this->shim().CreateWithSize(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&size)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithWidthAndHeight(void* resourceCreator, float width, float height, void** renderTarget) noexcept final try
        {
            clear_abi(renderTarget);
            typename D::abi_guard guard(this->shim());
            *renderTarget = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget>(this->shim().CreateWithWidthAndHeight(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const*>(&resourceCreator), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithWidthAndHeightAndDpi(void* resourceCreator, float width, float height, float dpi, void** renderTarget) noexcept final try
        {
            clear_abi(renderTarget);
            typename D::abi_guard guard(this->shim());
            *renderTarget = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget>(this->shim().CreateWithWidthAndHeightAndDpi(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), width, height, dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(void* resourceCreator, float width, float height, float dpi, int32_t format, int32_t alpha, void** renderTarget) noexcept final try
        {
            clear_abi(renderTarget);
            typename D::abi_guard guard(this->shim());
            *renderTarget = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget>(this->shim().CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), width, height, dpi, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics>
    {
        int32_t __stdcall CreateFromDirect3D11Surface(void* resourceCreator, void* surface, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget>(this->shim().CreateFromDirect3D11Surface(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const*>(&surface)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromDirect3D11SurfaceWithDpi(void* resourceCreator, void* surface, float dpi, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget>(this->shim().CreateFromDirect3D11Surface(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const*>(&surface), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateFromDirect3D11SurfaceWithDpiAndAlpha(void* resourceCreator, void* surface, float dpi, int32_t alpha, void** bitmap) noexcept final try
        {
            clear_abi(bitmap);
            typename D::abi_guard guard(this->shim());
            *bitmap = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget>(this->shim().CreateFromDirect3D11Surface(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const*>(&surface), dpi, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator>
    {
        int32_t __stdcall get_Device(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi>
    {
        int32_t __stdcall get_Dpi(float* dpi) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *dpi = detach_from<float>(this->shim().Dpi());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ConvertPixelsToDips(int32_t pixels, float* dips) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *dips = detach_from<float>(this->shim().ConvertPixelsToDips(pixels));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ConvertDipsToPixels(float dips, int32_t dpiRounding, int32_t* pixels) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *pixels = detach_from<int32_t>(this->shim().ConvertDipsToPixels(dips, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasDpiRounding const*>(&dpiRounding)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch>
    {
        int32_t __stdcall DrawToRect(void* bitmap, winrt::Windows::Foundation::Rect destRect) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destRect));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawAtOffset(void* bitmap, winrt::Windows::Foundation::Numerics::float2 offset) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawWithTransform(void* bitmap, winrt::Windows::Foundation::Numerics::float3x2 transform) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawToRectWithTint(void* bitmap, winrt::Windows::Foundation::Rect destRect, winrt::Windows::Foundation::Numerics::float4 tint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destRect), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawAtOffsetWithTint(void* bitmap, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Numerics::float4 tint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawWithTransformAndTint(void* bitmap, winrt::Windows::Foundation::Numerics::float3x2 transform, winrt::Windows::Foundation::Numerics::float4 tint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawToRectWithTintAndFlip(void* bitmap, winrt::Windows::Foundation::Rect destRect, winrt::Windows::Foundation::Numerics::float4 tint, uint32_t flip) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destRect), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const*>(&flip));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawWithTransformAndTintAndFlip(void* bitmap, winrt::Windows::Foundation::Numerics::float3x2 transform, winrt::Windows::Foundation::Numerics::float4 tint, uint32_t flip) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const*>(&flip));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawAtOffsetWithTintAndTransform(void* bitmap, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Numerics::float4 tint, winrt::Windows::Foundation::Numerics::float2 origin, float rotation, winrt::Windows::Foundation::Numerics::float2 scale, uint32_t flip) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Draw(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&origin), rotation, *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&scale), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const*>(&flip));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetToRect(void* bitmap, winrt::Windows::Foundation::Rect destRect, winrt::Windows::Foundation::Rect sourceRect) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destRect), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetAtOffset(void* bitmap, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Rect sourceRect) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetWithTransform(void* bitmap, winrt::Windows::Foundation::Numerics::float3x2 transform, winrt::Windows::Foundation::Rect sourceRect) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetToRectWithTint(void* bitmap, winrt::Windows::Foundation::Rect destRect, winrt::Windows::Foundation::Rect sourceRect, winrt::Windows::Foundation::Numerics::float4 tint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destRect), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetAtOffsetWithTint(void* bitmap, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Rect sourceRect, winrt::Windows::Foundation::Numerics::float4 tint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetWithTransformAndTint(void* bitmap, winrt::Windows::Foundation::Numerics::float3x2 transform, winrt::Windows::Foundation::Rect sourceRect, winrt::Windows::Foundation::Numerics::float4 tint) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetToRectWithTintAndFlip(void* bitmap, winrt::Windows::Foundation::Rect destRect, winrt::Windows::Foundation::Rect sourceRect, winrt::Windows::Foundation::Numerics::float4 tint, uint32_t flip) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&destRect), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const*>(&flip));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetWithTransformAndTintAndFlip(void* bitmap, winrt::Windows::Foundation::Numerics::float3x2 transform, winrt::Windows::Foundation::Rect sourceRect, winrt::Windows::Foundation::Numerics::float4 tint, uint32_t flip) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&transform), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const*>(&flip));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DrawFromSpriteSheetAtOffsetWithTintAndTransform(void* bitmap, winrt::Windows::Foundation::Numerics::float2 offset, winrt::Windows::Foundation::Rect sourceRect, winrt::Windows::Foundation::Numerics::float4 tint, winrt::Windows::Foundation::Numerics::float2 origin, float rotation, winrt::Windows::Foundation::Numerics::float2 scale, uint32_t flip) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DrawFromSpriteSheet(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasBitmap const*>(&bitmap), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&offset), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&sourceRect), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float4 const*>(&tint), *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&origin), rotation, *reinterpret_cast<winrt::Windows::Foundation::Numerics::float2 const*>(&scale), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSpriteFlip const*>(&flip));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatchStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatchStatics>
    {
        int32_t __stdcall IsSupported(void* device, bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsSupported(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasDevice const*>(&device)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain>
    {
        int32_t __stdcall Present() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Present();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall PresentWithSyncInterval(int32_t syncInterval) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Present(syncInterval);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResizeBuffersWithSize(winrt::Windows::Foundation::Size newSize) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ResizeBuffers(*reinterpret_cast<winrt::Windows::Foundation::Size const*>(&newSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResizeBuffersWithWidthAndHeight(float newWidth, float newHeight) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ResizeBuffers(newWidth, newHeight);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResizeBuffersWithWidthAndHeightAndDpi(float newWidth, float newHeight, float newDpi) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ResizeBuffers(newWidth, newHeight, newDpi);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall ResizeBuffersWithAllOptions(float newWidth, float newHeight, float newDpi, int32_t newFormat, int32_t bufferCount) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ResizeBuffers(newWidth, newHeight, newDpi, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&newFormat), bufferCount);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Size(winrt::Windows::Foundation::Size* size) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(size);
            typename D::abi_guard guard(this->shim());
            *size = detach_from<winrt::Windows::Foundation::Size>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SizeInPixels(struct struct_Windows_Graphics_Imaging_BitmapSize* size) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::Imaging::BitmapSize>(size);
            typename D::abi_guard guard(this->shim());
            *size = detach_from<winrt::Windows::Graphics::Imaging::BitmapSize>(this->shim().SizeInPixels());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Format(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(this->shim().Format());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BufferCount(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().BufferCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AlphaMode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode>(this->shim().AlphaMode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Rotation(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChainRotation>(this->shim().Rotation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Rotation(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Rotation(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSwapChainRotation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SourceSize(winrt::Windows::Foundation::Size* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Size>(this->shim().SourceSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SourceSize(winrt::Windows::Foundation::Size value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SourceSize(*reinterpret_cast<winrt::Windows::Foundation::Size const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TransformMatrix(winrt::Windows::Foundation::Numerics::float3x2* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Numerics::float3x2>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Numerics::float3x2>(this->shim().TransformMatrix());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_TransformMatrix(winrt::Windows::Foundation::Numerics::float3x2 value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TransformMatrix(*reinterpret_cast<winrt::Windows::Foundation::Numerics::float3x2 const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateDrawingSession(struct struct_Windows_UI_Color clearColor, void** drawingSession) noexcept final try
        {
            clear_abi(drawingSession);
            typename D::abi_guard guard(this->shim());
            *drawingSession = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession>(this->shim().CreateDrawingSession(*reinterpret_cast<winrt::Windows::UI::Color const*>(&clearColor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall WaitForVerticalBlank() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WaitForVerticalBlank();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory>
    {
        int32_t __stdcall CreateWithSize(void* resourceCreator, winrt::Windows::Foundation::Size size, void** swapChain) noexcept final try
        {
            clear_abi(swapChain);
            typename D::abi_guard guard(this->shim());
            *swapChain = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain>(this->shim().CreateWithSize(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&size)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithWidthAndHeight(void* resourceCreator, float width, float height, void** swapChain) noexcept final try
        {
            clear_abi(swapChain);
            typename D::abi_guard guard(this->shim());
            *swapChain = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain>(this->shim().CreateWithWidthAndHeight(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const*>(&resourceCreator), width, height));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithWidthAndHeightAndDpi(void* resourceCreator, float width, float height, float dpi, void** swapChain) noexcept final try
        {
            clear_abi(swapChain);
            typename D::abi_guard guard(this->shim());
            *swapChain = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain>(this->shim().CreateWithWidthAndHeightAndDpi(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), width, height, dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWithAllOptions(void* resourceCreator, float width, float height, float dpi, int32_t format, int32_t bufferCount, int32_t alphaMode, void** swapChain) noexcept final try
        {
            clear_abi(swapChain);
            typename D::abi_guard guard(this->shim());
            *swapChain = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain>(this->shim().CreateWithAllOptions(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), width, height, dpi, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format), bufferCount, *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alphaMode)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics>
    {
        int32_t __stdcall CreateForCoreWindowWithDpi(void* resourceCreator, void* coreWindow, float dpi, void** swapChain) noexcept final try
        {
            clear_abi(swapChain);
            typename D::abi_guard guard(this->shim());
            *swapChain = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain>(this->shim().CreateForCoreWindow(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::UI::Core::CoreWindow const*>(&coreWindow), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateForCoreWindowWithAllOptions(void* resourceCreator, void* coreWindow, float width, float height, float dpi, int32_t format, int32_t bufferCount, void** swapChain) noexcept final try
        {
            clear_abi(swapChain);
            typename D::abi_guard guard(this->shim());
            *swapChain = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain>(this->shim().CreateForCoreWindow(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::UI::Core::CoreWindow const*>(&coreWindow), width, height, dpi, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format), bufferCount));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateForWindowIdWithDpi(void* resourceCreator, struct struct_Microsoft_UI_WindowId windowId, float width, float height, float dpi, void** swapChain) noexcept final try
        {
            clear_abi(swapChain);
            typename D::abi_guard guard(this->shim());
            *swapChain = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain>(this->shim().CreateForWindowId(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId), width, height, dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateForWindowIdWithAllOptions(void* resourceCreator, struct struct_Microsoft_UI_WindowId windowId, float width, float height, float dpi, int32_t format, int32_t bufferCount, void** swapChain) noexcept final try
        {
            clear_abi(swapChain);
            typename D::abi_guard guard(this->shim());
            *swapChain = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain>(this->shim().CreateForWindowId(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Microsoft::UI::WindowId const*>(&windowId), width, height, dpi, *reinterpret_cast<winrt::Windows::Graphics::DirectX::DirectXPixelFormat const*>(&format), bufferCount));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap>
    {
        int32_t __stdcall get_Device(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().Device());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsCachedOnDemand(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsCachedOnDemand());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SizeInPixels(struct struct_Windows_Graphics_Imaging_BitmapSize* value) noexcept final try
        {
            zero_abi<winrt::Windows::Graphics::Imaging::BitmapSize>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Graphics::Imaging::BitmapSize>(this->shim().SizeInPixels());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Size(winrt::Windows::Foundation::Size* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Size>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Size>(this->shim().Size());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Bounds(winrt::Windows::Foundation::Rect* value) noexcept final try
        {
            zero_abi<winrt::Windows::Foundation::Rect>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Rect>(this->shim().Bounds());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics>
    {
        int32_t __stdcall LoadAsyncFromFileName(void* resourceCreator, void* fileName, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<hstring const*>(&fileName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromFileNameWithOptions(void* resourceCreator, void* fileName, int32_t options, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<hstring const*>(&fileName), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromFileNameWithOptionsAndAlpha(void* resourceCreator, void* fileName, int32_t options, int32_t alpha, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<hstring const*>(&fileName), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const*>(&options), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromUri(void* resourceCreator, void* uri, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&uri)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromUriWithOptions(void* resourceCreator, void* uri, int32_t options, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&uri), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromUriWithOptionsAndAlpha(void* resourceCreator, void* uri, int32_t options, int32_t alpha, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&uri), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const*>(&options), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromStream(void* resourceCreator, void* stream, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromStreamWithOptions(void* resourceCreator, void* stream, int32_t options, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const*>(&options)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LoadAsyncFromStreamWithOptionsAndAlpha(void* resourceCreator, void* stream, int32_t options, int32_t alpha, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::IAsyncOperation<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap>>(this->shim().LoadAsync(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const*>(&resourceCreator), *reinterpret_cast<winrt::Windows::Storage::Streams::IRandomAccessStream const*>(&stream), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const*>(&options), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const*>(&alpha)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Graphics::Canvas
{
    constexpr auto operator|(CanvasLayerOptions const left, CanvasLayerOptions const right) noexcept
    {
        return static_cast<CanvasLayerOptions>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(CanvasLayerOptions& left, CanvasLayerOptions const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(CanvasLayerOptions const left, CanvasLayerOptions const right) noexcept
    {
        return static_cast<CanvasLayerOptions>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(CanvasLayerOptions& left, CanvasLayerOptions const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(CanvasLayerOptions const value) noexcept
    {
        return static_cast<CanvasLayerOptions>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(CanvasLayerOptions const left, CanvasLayerOptions const right) noexcept
    {
        return static_cast<CanvasLayerOptions>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(CanvasLayerOptions& left, CanvasLayerOptions const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    constexpr auto operator|(CanvasSpriteFlip const left, CanvasSpriteFlip const right) noexcept
    {
        return static_cast<CanvasSpriteFlip>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(CanvasSpriteFlip& left, CanvasSpriteFlip const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(CanvasSpriteFlip const left, CanvasSpriteFlip const right) noexcept
    {
        return static_cast<CanvasSpriteFlip>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(CanvasSpriteFlip& left, CanvasSpriteFlip const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(CanvasSpriteFlip const value) noexcept
    {
        return static_cast<CanvasSpriteFlip>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(CanvasSpriteFlip const left, CanvasSpriteFlip const right) noexcept
    {
        return static_cast<CanvasSpriteFlip>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(CanvasSpriteFlip& left, CanvasSpriteFlip const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    constexpr auto operator|(CanvasSpriteOptions const left, CanvasSpriteOptions const right) noexcept
    {
        return static_cast<CanvasSpriteOptions>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(CanvasSpriteOptions& left, CanvasSpriteOptions const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(CanvasSpriteOptions const left, CanvasSpriteOptions const right) noexcept
    {
        return static_cast<CanvasSpriteOptions>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(CanvasSpriteOptions& left, CanvasSpriteOptions const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(CanvasSpriteOptions const value) noexcept
    {
        return static_cast<CanvasSpriteOptions>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(CanvasSpriteOptions const left, CanvasSpriteOptions const right) noexcept
    {
        return static_cast<CanvasSpriteOptions>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(CanvasSpriteOptions& left, CanvasSpriteOptions const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline auto CanvasBitmap::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromDirect3D11Surface(resourceCreator, surface); });
    }
    inline auto CanvasBitmap::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface, float dpi)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromDirect3D11Surface(resourceCreator, surface, dpi); });
    }
    inline auto CanvasBitmap::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromDirect3D11Surface(resourceCreator, surface, dpi, alpha); });
    }
    inline auto CanvasBitmap::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<uint8_t const> bytes, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromBytes(resourceCreator, bytes, widthInPixels, heightInPixels, format); });
    }
    inline auto CanvasBitmap::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<uint8_t const> bytes, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, float dpi)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromBytes(resourceCreator, bytes, widthInPixels, heightInPixels, format, dpi); });
    }
    inline auto CanvasBitmap::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<uint8_t const> bytes, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromBytes(resourceCreator, bytes, widthInPixels, heightInPixels, format, dpi, alpha); });
    }
    inline auto CanvasBitmap::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IBuffer const& buffer, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromBytes(resourceCreator, buffer, widthInPixels, heightInPixels, format); });
    }
    inline auto CanvasBitmap::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IBuffer const& buffer, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, float dpi)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromBytes(resourceCreator, buffer, widthInPixels, heightInPixels, format, dpi); });
    }
    inline auto CanvasBitmap::CreateFromBytes(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IBuffer const& buffer, int32_t widthInPixels, int32_t heightInPixels, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromBytes(resourceCreator, buffer, widthInPixels, heightInPixels, format, dpi, alpha); });
    }
    inline auto CanvasBitmap::CreateFromColors(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Windows::UI::Color const> colors, int32_t widthInPixels, int32_t heightInPixels)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromColors(resourceCreator, colors, widthInPixels, heightInPixels); });
    }
    inline auto CanvasBitmap::CreateFromColors(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Windows::UI::Color const> colors, int32_t widthInPixels, int32_t heightInPixels, float dpi)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromColors(resourceCreator, colors, widthInPixels, heightInPixels, dpi); });
    }
    inline auto CanvasBitmap::CreateFromColors(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, array_view<winrt::Windows::UI::Color const> colors, int32_t widthInPixels, int32_t heightInPixels, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromColors(resourceCreator, colors, widthInPixels, heightInPixels, dpi, alpha); });
    }
    inline auto CanvasBitmap::CreateFromSoftwareBitmap(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::Imaging::SoftwareBitmap const& sourceBitmap)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.CreateFromSoftwareBitmap(resourceCreator, sourceBitmap); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, fileName); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName, float dpi)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, fileName, dpi); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, fileName, dpi, alpha); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, uri); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri, float dpi)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, uri, dpi); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, uri, dpi, alpha); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, stream); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, float dpi)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, stream, dpi); });
    }
    inline auto CanvasBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasBitmap, ICanvasBitmapStatics>([&](ICanvasBitmapStatics const& f) { return f.LoadAsync(resourceCreator, stream, dpi, alpha); });
    }
    inline CanvasCommandList::CanvasCommandList(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator) :
        CanvasCommandList(impl::call_factory<CanvasCommandList, ICanvasCommandListFactory>([&](ICanvasCommandListFactory const& f) { return f.Create(resourceCreator); }))
    {
    }
    inline CanvasDevice::CanvasDevice() :
        CanvasDevice(impl::call_factory_cast<CanvasDevice(*)(winrt::Windows::Foundation::IActivationFactory const&), CanvasDevice>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<CanvasDevice>(); }))
    {
    }
    inline CanvasDevice::CanvasDevice(bool forceSoftwareRenderer) :
        CanvasDevice(impl::call_factory<CanvasDevice, ICanvasDeviceFactory>([&](ICanvasDeviceFactory const& f) { return f.CreateWithForceSoftwareRendererOption(forceSoftwareRenderer); }))
    {
    }
    inline auto CanvasDevice::CreateFromDirect3D11Device(winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice const& direct3DDevice)
    {
        return impl::call_factory<CanvasDevice, ICanvasDeviceStatics>([&](ICanvasDeviceStatics const& f) { return f.CreateFromDirect3D11Device(direct3DDevice); });
    }
    inline auto CanvasDevice::GetSharedDevice()
    {
        return impl::call_factory_cast<winrt::Microsoft::Graphics::Canvas::CanvasDevice(*)(ICanvasDeviceStatics const&), CanvasDevice, ICanvasDeviceStatics>([](ICanvasDeviceStatics const& f) { return f.GetSharedDevice(); });
    }
    inline auto CanvasDevice::GetSharedDevice(bool forceSoftwareRenderer)
    {
        return impl::call_factory<CanvasDevice, ICanvasDeviceStatics>([&](ICanvasDeviceStatics const& f) { return f.GetSharedDevice(forceSoftwareRenderer); });
    }
    inline auto CanvasDevice::DebugLevel(winrt::Microsoft::Graphics::Canvas::CanvasDebugLevel const& value)
    {
        impl::call_factory<CanvasDevice, ICanvasDeviceStatics>([&](ICanvasDeviceStatics const& f) { return f.DebugLevel(value); });
    }
    inline auto CanvasDevice::DebugLevel()
    {
        return impl::call_factory_cast<winrt::Microsoft::Graphics::Canvas::CanvasDebugLevel(*)(ICanvasDeviceStatics const&), CanvasDevice, ICanvasDeviceStatics>([](ICanvasDeviceStatics const& f) { return f.DebugLevel(); });
    }
    inline auto CanvasImage::SaveAsync(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& sourceRectangle, float dpi, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat)
    {
        return impl::call_factory<CanvasImage, ICanvasImageStatics>([&](ICanvasImageStatics const& f) { return f.SaveAsync(image, sourceRectangle, dpi, resourceCreator, stream, fileFormat); });
    }
    inline auto CanvasImage::SaveAsync(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& sourceRectangle, float dpi, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat, float quality)
    {
        return impl::call_factory<CanvasImage, ICanvasImageStatics>([&](ICanvasImageStatics const& f) { return f.SaveAsync(image, sourceRectangle, dpi, resourceCreator, stream, fileFormat, quality); });
    }
    inline auto CanvasImage::SaveAsync(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& sourceRectangle, float dpi, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasBitmapFileFormat const& fileFormat, float quality, winrt::Microsoft::Graphics::Canvas::CanvasBufferPrecision const& bufferPrecision)
    {
        return impl::call_factory<CanvasImage, ICanvasImageStatics>([&](ICanvasImageStatics const& f) { return f.SaveAsync(image, sourceRectangle, dpi, resourceCreator, stream, fileFormat, quality, bufferPrecision); });
    }
    inline auto CanvasImage::ComputeHistogram(winrt::Microsoft::Graphics::Canvas::ICanvasImage const& image, winrt::Windows::Foundation::Rect const& sourceRectangle, winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Microsoft::Graphics::Canvas::Effects::EffectChannelSelect const& channelSelect, int32_t numberOfBins)
    {
        return impl::call_factory<CanvasImage, ICanvasImageStatics>([&](ICanvasImageStatics const& f) { return f.ComputeHistogram(image, sourceRectangle, resourceCreator, channelSelect, numberOfBins); });
    }
    inline auto CanvasImage::IsHistogramSupported(winrt::Microsoft::Graphics::Canvas::CanvasDevice const& device)
    {
        return impl::call_factory<CanvasImage, ICanvasImageStatics>([&](ICanvasImageStatics const& f) { return f.IsHistogramSupported(device); });
    }
    inline CanvasRenderTarget::CanvasRenderTarget(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const& resourceCreator, winrt::Windows::Foundation::Size const& size) :
        CanvasRenderTarget(impl::call_factory<CanvasRenderTarget, ICanvasRenderTargetFactory>([&](ICanvasRenderTargetFactory const& f) { return f.CreateWithSize(resourceCreator, size); }))
    {
    }
    inline CanvasRenderTarget::CanvasRenderTarget(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const& resourceCreator, float width, float height) :
        CanvasRenderTarget(impl::call_factory<CanvasRenderTarget, ICanvasRenderTargetFactory>([&](ICanvasRenderTargetFactory const& f) { return f.CreateWithWidthAndHeight(resourceCreator, width, height); }))
    {
    }
    inline CanvasRenderTarget::CanvasRenderTarget(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float width, float height, float dpi) :
        CanvasRenderTarget(impl::call_factory<CanvasRenderTarget, ICanvasRenderTargetFactory>([&](ICanvasRenderTargetFactory const& f) { return f.CreateWithWidthAndHeightAndDpi(resourceCreator, width, height, dpi); }))
    {
    }
    inline CanvasRenderTarget::CanvasRenderTarget(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float width, float height, float dpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha) :
        CanvasRenderTarget(impl::call_factory<CanvasRenderTarget, ICanvasRenderTargetFactory>([&](ICanvasRenderTargetFactory const& f) { return f.CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(resourceCreator, width, height, dpi, format, alpha); }))
    {
    }
    inline auto CanvasRenderTarget::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface)
    {
        return impl::call_factory<CanvasRenderTarget, ICanvasRenderTargetStatics>([&](ICanvasRenderTargetStatics const& f) { return f.CreateFromDirect3D11Surface(resourceCreator, surface); });
    }
    inline auto CanvasRenderTarget::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface, float dpi)
    {
        return impl::call_factory<CanvasRenderTarget, ICanvasRenderTargetStatics>([&](ICanvasRenderTargetStatics const& f) { return f.CreateFromDirect3D11Surface(resourceCreator, surface, dpi); });
    }
    inline auto CanvasRenderTarget::CreateFromDirect3D11Surface(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface const& surface, float dpi, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasRenderTarget, ICanvasRenderTargetStatics>([&](ICanvasRenderTargetStatics const& f) { return f.CreateFromDirect3D11Surface(resourceCreator, surface, dpi, alpha); });
    }
    inline auto CanvasSpriteBatch::IsSupported(winrt::Microsoft::Graphics::Canvas::CanvasDevice const& device)
    {
        return impl::call_factory<CanvasSpriteBatch, ICanvasSpriteBatchStatics>([&](ICanvasSpriteBatchStatics const& f) { return f.IsSupported(device); });
    }
    inline CanvasSwapChain::CanvasSwapChain(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const& resourceCreator, winrt::Windows::Foundation::Size const& size) :
        CanvasSwapChain(impl::call_factory<CanvasSwapChain, ICanvasSwapChainFactory>([&](ICanvasSwapChainFactory const& f) { return f.CreateWithSize(resourceCreator, size); }))
    {
    }
    inline CanvasSwapChain::CanvasSwapChain(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi const& resourceCreator, float width, float height) :
        CanvasSwapChain(impl::call_factory<CanvasSwapChain, ICanvasSwapChainFactory>([&](ICanvasSwapChainFactory const& f) { return f.CreateWithWidthAndHeight(resourceCreator, width, height); }))
    {
    }
    inline CanvasSwapChain::CanvasSwapChain(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float width, float height, float dpi) :
        CanvasSwapChain(impl::call_factory<CanvasSwapChain, ICanvasSwapChainFactory>([&](ICanvasSwapChainFactory const& f) { return f.CreateWithWidthAndHeightAndDpi(resourceCreator, width, height, dpi); }))
    {
    }
    inline CanvasSwapChain::CanvasSwapChain(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, float width, float height, float dpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, int32_t bufferCount, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alphaMode) :
        CanvasSwapChain(impl::call_factory<CanvasSwapChain, ICanvasSwapChainFactory>([&](ICanvasSwapChainFactory const& f) { return f.CreateWithAllOptions(resourceCreator, width, height, dpi, format, bufferCount, alphaMode); }))
    {
    }
    inline auto CanvasSwapChain::CreateForCoreWindow(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Core::CoreWindow const& coreWindow, float dpi)
    {
        return impl::call_factory<CanvasSwapChain, ICanvasSwapChainStatics>([&](ICanvasSwapChainStatics const& f) { return f.CreateForCoreWindow(resourceCreator, coreWindow, dpi); });
    }
    inline auto CanvasSwapChain::CreateForCoreWindow(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::UI::Core::CoreWindow const& coreWindow, float width, float height, float dpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, int32_t bufferCount)
    {
        return impl::call_factory<CanvasSwapChain, ICanvasSwapChainStatics>([&](ICanvasSwapChainStatics const& f) { return f.CreateForCoreWindow(resourceCreator, coreWindow, width, height, dpi, format, bufferCount); });
    }
    inline auto CanvasSwapChain::CreateForWindowId(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Microsoft::UI::WindowId const& windowId, float width, float height, float dpi)
    {
        return impl::call_factory<CanvasSwapChain, ICanvasSwapChainStatics>([&](ICanvasSwapChainStatics const& f) { return f.CreateForWindowId(resourceCreator, windowId, width, height, dpi); });
    }
    inline auto CanvasSwapChain::CreateForWindowId(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Microsoft::UI::WindowId const& windowId, float width, float height, float dpi, winrt::Windows::Graphics::DirectX::DirectXPixelFormat const& format, int32_t bufferCount)
    {
        return impl::call_factory<CanvasSwapChain, ICanvasSwapChainStatics>([&](ICanvasSwapChainStatics const& f) { return f.CreateForWindowId(resourceCreator, windowId, width, height, dpi, format, bufferCount); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, fileName); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, fileName, options); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, param::hstring const& fileName, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, fileName, options, alpha); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, uri); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, uri, options); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Foundation::Uri const& uri, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, uri, options, alpha); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, stream); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, stream, options); });
    }
    inline auto CanvasVirtualBitmap::LoadAsync(winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator const& resourceCreator, winrt::Windows::Storage::Streams::IRandomAccessStream const& stream, winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmapOptions const& options, winrt::Microsoft::Graphics::Canvas::CanvasAlphaMode const& alpha)
    {
        return impl::call_factory<CanvasVirtualBitmap, ICanvasVirtualBitmapStatics>([&](ICanvasVirtualBitmapStatics const& f) { return f.LoadAsync(resourceCreator, stream, options, alpha); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasActiveLayer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasBitmap> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasBitmapStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasCommandList> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasCommandListFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasDevice> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasDeviceStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasDrawingSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasImage> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasImageStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasLock> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTarget> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasRenderTargetStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreator> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasResourceCreatorWithDpi> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatch> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasSpriteBatchStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChain> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasSwapChainStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmap> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::ICanvasVirtualBitmapStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasActiveLayer> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasBitmap> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasCommandList> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasDevice> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasImage> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasLock> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasRenderTarget> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasSpriteBatch> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::CanvasVirtualBitmap> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
